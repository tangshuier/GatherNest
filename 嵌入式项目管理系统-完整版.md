# 嵌入式项目管理系统开发文档

## 目录

1. [项目概述](#项目概述)
   - [1.1 项目背景](#项目背景)
   - [1.2 项目目标](#项目目标)
   - [1.3 面向用户](#面向用户)
2. [功能需求分析](#功能需求分析)
   - [2.1 权限管理模块](#权限管理模块)
   - [2.2 项目管理模块](#项目管理模块)
   - [2.3 人员管理模块](#人员管理模块)
   - [2.4 资料管理模块](#资料管理模块)
3. [系统架构设计](#系统架构设计)
   - [3.1 技术架构](#技术架构)
   - [3.2 系统分层](#系统分层)
   - [3.3 详细数据库设计](#详细数据库设计)
   - [3.4 数据库性能优化](#数据库性能优化)
   - [3.5 API接口设计](#api接口设计)
   - [3.6 开发规范](#开发规范)
4. [详细功能设计](#详细功能设计)
   - [4.1 权限管理模块详细设计](#权限管理模块详细设计)
   - [4.2 项目管理模块详细设计](#项目管理模块详细设计)
   - [4.3 人员管理模块详细设计](#人员管理模块详细设计)
   - [4.4 资料管理模块详细设计](#资料管理模块详细设计)
   - [4.5 项目修改提示服务实现](#项目修改提示服务实现)
   - [4.6 安全与性能优化](#安全与性能优化)
   - [4.7 错误处理与日志标准化](#错误处理与日志标准化)
   - [4.8 系统部署与维护](#系统部署与维护)
   - [4.9 数据导入导出模块设计](#数据导入导出模块设计)
   - [4.10 通知系统设计](#通知系统设计)
   - [4.11 审批工作流设计](#审批工作流设计)
   - [4.12 移动端适配设计](#移动端适配设计)
   - [4.13 版本控制增强设计](#版本控制增强设计)
   - [4.14 测试管理设计](#测试管理设计)
   - [4.15 硬件资源管理设计](#硬件资源管理设计)
5. [数据库设计](#数据库设计)
6. [API接口设计](#api接口设计-1)
7. [安全与权限设计](#安全与权限设计-1)
8. [代码规范](#代码规范-1)
9. [测试计划](#测试计划)

## 1. 项目概述

### 1.1 项目背景
随着嵌入式技术的快速发展，中小型企业或工作室在嵌入式设备开发和管理过程中面临着权限管理、人员协同、项目跟踪和资料管理等多方面的挑战。本系统旨在提供一个一体化的本地部署解决方案，帮助企业规范管理流程，提高工作效率，确保项目质量。

### 1.2 项目目标
开发一套完整的嵌入式项目管理系统，满足企业在权限分配、人员管理、项目管理和资料管理方面的需求，实现高效协同工作和规范化管理。

### 1.3 面向用户
中小型嵌入式开发企业、工作室、研发团队等。

## 2. 功能需求分析

### 2.1 权限管理模块

#### 2.1.1 权限体系设计
- **RBAC权限模型**：采用基于角色的访问控制模型，支持权限的灵活组合和继承
- **六级权限体系**：
  - **超级管理员**：系统唯一创建者，拥有最高权限，可管理所有用户、项目和资料
  - **高级管理员**：公司老板角色，可管理除超级管理员外的所有用户和内容
  - **中级管理员**：部门负责人角色，管理本部门人员和相关项目
  - **普通管理员**：小组组长角色，管理本小组人员和负责的项目
  - **普通员工**：一线开发人员，根据分配权限访问相关资源
  - **试岗员工**：临时或试用人员，权限受限，有试用期限制
- **权限组合策略**：支持权限的逻辑或（OR）和逻辑与（AND）组合方式
- **角色继承机制**：通过继承关系简化权限管理，下级角色自动获得上级角色的基础权限
- **标准角色库**：预设常用角色组合，覆盖80%的业务场景需求

#### 2.1.2 权限分配功能
- 为不同级别用户分配对应权限
- 支持自定义权限组
- 权限可精确到具体功能模块和数据项
- 批量权限分配功能

#### 2.1.3 权限校验功能
- 用户登录时的身份验证
- 操作前的权限检查
- 资料访问权限控制
- 敏感操作的权限确认
- 统一的权限验证中间件

#### 2.1.4 权限管理功能
- 权限的创建、修改和删除
- 用户权限的批量调整
- 权限变更记录和审计
- 权限缓存机制，减少数据库查询

### 2.2 项目管理模块

#### 2.2.1 项目类型管理
- **成品项目**：公司已完成的标准化产品，可直接复制方案生产
- **定制项目**：根据客户需求定制的非标准化产品

#### 2.2.2 项目转换功能
- 定制项目完成后可转换为成品项目
- 成品项目可基于原有方案修改为定制项目

#### 2.2.3 项目内容管理
- **论文类项目**：主要包含文档资料
- **实物类项目**：包含硬件及相关资料
  - 硬件程序工程
  - 硬件实物图
  - 接线图
  - 原理图
  - 硬件原理图工程
  - 器材清单等

#### 2.2.4 项目生命周期管理
- 项目创建与初始化
- 项目进度跟踪
- 项目成员分配
- 项目状态管理（基于状态机模式）
- 项目归档

### 2.3 人员管理模块

#### 2.3.1 员工信息管理
- 员工基本信息录入与存储
- 员工详细资料管理（联系方式、技能特长、教育背景等）
- 员工信息查询与统计
- 员工信息批量导入导出

#### 2.3.2 员工生命周期管理
- 新员工入职流程
- 员工离职处理（资料交接、权限移除）
- 员工岗位变动（权限调整、部门调动）
- 试用期管理和自动提醒

#### 2.3.3 员工权限管理
- 员工晋升流程
- 权限变更申请与审批
- 权限历史记录
- 批量角色和权限分配

### 2.4 资料管理模块

#### 2.4.1 项目资料管理
- 文档上传与管理（支持多种格式）
- 硬件资料管理
- 资料版本控制（语义化版本号）
- 资料分类与标签系统
- 历史版本查看与回滚

#### 2.4.2 资料查询与检索
- 全文搜索功能（多字段索引）
- 多条件筛选
- 按权限过滤结果
- 搜索结果排序与高亮

## 3. 系统架构设计

### 3.1 技术架构
- **后端技术栈**：Node.js + Express
- **数据库**：PostgreSQL（推荐）/ SQLite（本地部署）
- **前端技术栈**：React + Ant Design
- **存储方案**：分布式存储（MinIO对象存储）
- **API规范**：RESTful API + OpenAPI 3.0

### 3.2 系统分层
- **Controller层**：仅负责HTTP请求处理
- **Service层**：核心业务逻辑，事务控制
- **Repository层**：数据访问抽象
- **Domain层**：业务实体和领域规则
- **基础设施层**：数据库、缓存、消息队列等

### 3.3 详细数据库设计

#### 3.3.1 数据库表结构
- **用户表（users）**
  ```sql
  CREATE TABLE users (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    real_name VARCHAR(50) NOT NULL,
    email VARCHAR(100),
    phone VARCHAR(20),
    department_id VARCHAR(36),
    position VARCHAR(50),
    role VARCHAR(50) NOT NULL,
    status VARCHAR(20) DEFAULT 'active',
    entry_date DATE,
    probation_period INTEGER,
    last_login_time DATETIME,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (department_id) REFERENCES departments(id)
  );
  CREATE INDEX idx_users_username ON users(username);
  CREATE INDEX idx_users_department_id ON users(department_id);
  CREATE INDEX idx_users_role ON users(role);
  ```

- **部门表（departments）**
  ```sql
  CREATE TABLE departments (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(100) NOT NULL UNIQUE,
    parent_id VARCHAR(36),
    description TEXT,
    sort INTEGER DEFAULT 0,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_id) REFERENCES departments(id)
  );
  CREATE INDEX idx_departments_parent_id ON departments(parent_id);
  ```

- **项目表（projects）**
  ```sql
  CREATE TABLE projects (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    code VARCHAR(50) UNIQUE,
    type VARCHAR(50),
    status VARCHAR(50) DEFAULT 'planning',
    manager_id VARCHAR(36),
    start_date DATE,
    end_date DATE,
    estimated_hours INTEGER,
    actual_hours INTEGER DEFAULT 0,
    priority VARCHAR(20) DEFAULT 'medium',
    budget DECIMAL(12,2),
    actual_cost DECIMAL(12,2) DEFAULT 0,
    progress INTEGER DEFAULT 0,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (manager_id) REFERENCES users(id)
  );
  CREATE INDEX idx_projects_manager_id ON projects(manager_id);
  CREATE INDEX idx_projects_status ON projects(status);
  CREATE INDEX idx_projects_code ON projects(code);
  ```

- **项目成员表（project_members）**
  ```sql
  CREATE TABLE project_members (
    project_id VARCHAR(36),
    user_id VARCHAR(36),
    role VARCHAR(50),
    join_date DATE,
    leave_date DATE,
    PRIMARY KEY (project_id, user_id),
    FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id)
  );
  CREATE INDEX idx_project_members_user_id ON project_members(user_id);
  ```

- **产品表（products）**
  ```sql
  CREATE TABLE products (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    code VARCHAR(50) UNIQUE,
    category_id VARCHAR(36),
    specifications TEXT,
    image_url VARCHAR(255),
    status VARCHAR(50) DEFAULT 'active',
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP
  );
  CREATE INDEX idx_products_code ON products(code);
  CREATE INDEX idx_products_category_id ON products(category_id);
  ```

- **资料表（materials）**
  ```sql
  CREATE TABLE materials (
    id VARCHAR(36) PRIMARY KEY,
    code VARCHAR(50) UNIQUE,
    title VARCHAR(200) NOT NULL,
    type VARCHAR(50),
    category_id VARCHAR(36),
    summary TEXT,
    content TEXT,
    cover VARCHAR(255),
    download_count INTEGER DEFAULT 0,
    view_count INTEGER DEFAULT 0,
    creator_id VARCHAR(36),
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (creator_id) REFERENCES users(id)
  );
  CREATE INDEX idx_materials_creator_id ON materials(creator_id);
  CREATE INDEX idx_materials_title ON materials(title);
  ```

- **资料附件表（material_attachments）**
  ```sql
  CREATE TABLE material_attachments (
    id VARCHAR(36) PRIMARY KEY,
    material_id VARCHAR(36),
    name VARCHAR(255) NOT NULL,
    url VARCHAR(255) NOT NULL,
    size INTEGER,
    type VARCHAR(100),
    upload_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (material_id) REFERENCES materials(id) ON DELETE CASCADE
  );
  CREATE INDEX idx_material_attachments_material_id ON material_attachments(material_id);
  ```

- **销售订单表（sales_orders）**
  ```sql
  CREATE TABLE sales_orders (
    id VARCHAR(36) PRIMARY KEY,
    order_no VARCHAR(50) UNIQUE NOT NULL,
    customer_id VARCHAR(36),
    salesman_id VARCHAR(36),
    total_amount DECIMAL(12,2) NOT NULL,
    payment_method VARCHAR(50),
    payment_status VARCHAR(50) DEFAULT 'unpaid',
    delivery_address TEXT,
    delivery_status VARCHAR(50) DEFAULT 'pending',
    remark TEXT,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    update_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (salesman_id) REFERENCES users(id)
  );
  CREATE INDEX idx_sales_orders_order_no ON sales_orders(order_no);
  CREATE INDEX idx_sales_orders_salesman_id ON sales_orders(salesman_id);
  ```

- **销售订单明细表（sales_order_items）**
  ```sql
  CREATE TABLE sales_order_items (
    id VARCHAR(36) PRIMARY KEY,
    order_id VARCHAR(36),
    product_id VARCHAR(36),
    product_name VARCHAR(200),
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(12,2) NOT NULL,
    total_price DECIMAL(12,2) NOT NULL,
    FOREIGN KEY (order_id) REFERENCES sales_orders(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id)
  );
  CREATE INDEX idx_sales_order_items_order_id ON sales_order_items(order_id);
  CREATE INDEX idx_sales_order_items_product_id ON sales_order_items(product_id);
  ```

- **权限表（permissions）**
  ```sql
  CREATE TABLE permissions (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    code VARCHAR(50) NOT NULL UNIQUE,
    type VARCHAR(20) NOT NULL, -- menu/api/button
    category VARCHAR(50),
    url VARCHAR(255),
    method VARCHAR(20),
    parent_id VARCHAR(36),
    sort INTEGER DEFAULT 0,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_id) REFERENCES permissions(id)
  );
  CREATE INDEX idx_permissions_code ON permissions(code);
  CREATE INDEX idx_permissions_type ON permissions(type);
  ```

- **角色权限关联表（role_permissions）**
  ```sql
  CREATE TABLE role_permissions (
    role VARCHAR(50),
    permission_id VARCHAR(36),
    PRIMARY KEY (role, permission_id),
    FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE
  );
  ```

- **操作日志表（operation_logs）**
  ```sql
  CREATE TABLE operation_logs (
    id VARCHAR(36) PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    operation VARCHAR(100) NOT NULL,
    module VARCHAR(100),
    ip VARCHAR(50),
    user_agent TEXT,
    params TEXT,
    result TEXT,
    success BOOLEAN DEFAULT TRUE,
    create_time DATETIME DEFAULT CURRENT_TIMESTAMP
  );
  CREATE INDEX idx_operation_logs_username ON operation_logs(username);
  CREATE INDEX idx_operation_logs_create_time ON operation_logs(create_time);
  ```

#### 3.3.2 数据模型优化
- **规范化数据模型**：将JSON字段转换为独立关联表
- **外键约束**：显式启用外键支持，确保数据一致性
- **索引优化**：为高频查询字段添加复合索引
- **示例优化**：
  ```sql
  -- 员工权限表优化示例
  CREATE TABLE employees (id INTEGER PRIMARY KEY);
  CREATE TABLE employee_permissions (
    employee_id INTEGER,
    permission_code VARCHAR(50),
    FOREIGN KEY (employee_id) REFERENCES employees(id) ON DELETE CASCADE
  );
  CREATE INDEX idx_emp_perm ON employee_permissions(employee_id);
  ```

### 3.4 数据库性能优化
- **数据库选型建议**：
  - PostgreSQL：推荐用于生产环境，性能更好
  - SQLite优化：设置合理的PRAGMA参数（journal_mode=WAL, synchronous=NORMAL）
- **数据分片策略**：
  - 按时间范围分片：历史数据归档
  - 按业务模块分片：功能模块分离
- **查询优化**：
  - 创建视图简化复杂查询
  - 使用连接池管理数据库连接
  - 查询性能监控和优化
- **缓存策略**：
  - 多级缓存架构：内存缓存 + 分布式缓存
  - 缓存预热和自动刷新机制
  - 基于TTL的缓存过期策略

### 3.5 API接口设计

#### 3.5.1 API设计规范
- **RESTful API标准化**：
  - 统一资源路径格式：`/api/{resource}/{id}?query`
  - 采用查询参数区分操作类型
  - 实现API版本控制：`/api/v1/projects`
- **请求响应格式统一**：
  - 统一响应结构：`{"code": 0, "data": {}, "message": ""}`
  - 分页参数和返回格式统一：`page, pageSize, total, items`
- **API文档自动生成**：
  - 集成Swagger/OpenAPI
  - 实现API测试沙箱

#### 3.5.2 认证相关接口

##### 3.5.2.1 用户登录接口
- **接口路径**：`POST /api/v1/auth/login`
- **请求体**：
  ```json
  {
    "username": "string",  // 用户名
    "password": "string"   // 密码
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "token": "string",       // JWT令牌
      "refreshToken": "string", // 刷新令牌
      "expireTime": "string",  // 过期时间
      "userInfo": {
        "id": "string",
        "username": "string",
        "realName": "string",
        "role": "string",      // 角色：super_admin/admin/regular/guest
        "permissions": ["string"] // 权限列表
      }
    },
    "message": "登录成功"
  }
  ```

##### 3.5.2.2 Token刷新接口
- **接口路径**：`POST /api/v1/auth/refresh`
- **请求头**：`Authorization: Bearer {refreshToken}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "token": "string",       // 新的JWT令牌
      "expireTime": "string"   // 新的过期时间
    },
    "message": "Token刷新成功"
  }
  ```

##### 3.5.2.3 用户登出接口
- **接口路径**：`POST /api/v1/auth/logout`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "登出成功"
  }
  ```

##### 3.5.2.4 获取当前用户信息接口
- **接口路径**：`GET /api/v1/auth/user-info`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "username": "string",
      "realName": "string",
      "email": "string",
      "phone": "string",
      "department": "string",
      "position": "string",
      "role": "string",      // 角色
      "permissions": ["string"], // 权限列表
      "avatar": "string",    // 头像URL
      "status": "string"     // 状态：active/inactive/on_probation
    },
    "message": "获取成功"
  }
  ```

##### 3.5.2.5 修改密码接口
- **接口路径**：`PUT /api/v1/auth/password`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "oldPassword": "string", // 旧密码
    "newPassword": "string"  // 新密码
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "密码修改成功"
  }
  ```

##### 3.5.2.6 重置密码接口（管理员使用）
- **接口路径**：`POST /api/v1/auth/reset-password`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "userId": "string",      // 用户ID
    "newPassword": "string"  // 新密码
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "密码重置成功"
  }
  ```

#### 3.5.3 用户管理接口

##### 3.5.3.1 获取用户列表接口
- **接口路径**：`GET /api/v1/users`
- **请求参数**：
  - `page`: 页码（默认1）
  - `pageSize`: 每页条数（默认10）
  - `keyword`: 搜索关键词（用户名/姓名）
  - `departmentId`: 部门ID
  - `role`: 角色筛选
  - `status`: 状态筛选
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "page": 1,
      "pageSize": 10,
      "total": 100,
      "items": [
        {
          "id": "string",
          "username": "string",
          "realName": "string",
          "email": "string",
          "phone": "string",
          "department": {
            "id": "string",
            "name": "string"
          },
          "position": "string",
          "role": "string",
          "status": "string",
          "createTime": "string",
          "lastLoginTime": "string"
        }
      ]
    },
    "message": "获取成功"
  }
  ```

##### 3.5.3.2 创建用户接口
- **接口路径**：`POST /api/v1/users`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "username": "string",
    "password": "string",
    "realName": "string",
    "email": "string",
    "phone": "string",
    "departmentId": "string",
    "position": "string",
    "role": "string",
    "status": "string",
    "entryDate": "string",
    "probationPeriod": 3 // 试用期（月）
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "username": "string",
      "realName": "string"
    },
    "message": "创建成功"
  }
  ```

##### 3.5.3.3 获取用户详情接口
- **接口路径**：`GET /api/v1/users/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "username": "string",
      "realName": "string",
      "email": "string",
      "phone": "string",
      "department": {
        "id": "string",
        "name": "string"
      },
      "position": "string",
      "role": "string",
      "permissions": ["string"],
      "status": "string",
      "entryDate": "string",
      "probationEndDate": "string",
      "createTime": "string",
      "updateTime": "string"
    },
    "message": "获取成功"
  }
  ```

##### 3.5.3.4 更新用户接口
- **接口路径**：`PUT /api/v1/users/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "realName": "string",
    "email": "string",
    "phone": "string",
    "departmentId": "string",
    "position": "string",
    "role": "string",
    "status": "string"
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "更新成功"
  }
  ```

##### 3.5.3.5 批量更新用户状态接口
- **接口路径**：`PUT /api/v1/users/batch-status`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "userIds": ["string"],
    "status": "string"
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "successCount": 10,
      "failCount": 0
    },
    "message": "批量更新成功"
  }
  ```

#### 3.5.4 项目管理接口

##### 3.5.4.1 获取项目列表接口
- **接口路径**：`GET /api/v1/projects`
- **请求参数**：
  - `page`: 页码（默认1）
  - `pageSize`: 每页条数（默认10）
  - `keyword`: 搜索关键词（项目名称/编号）
  - `status`: 项目状态筛选
  - `type`: 项目类型筛选
  - `managerId`: 项目经理ID
  - `startDate`: 开始日期（范围查询）
  - `endDate`: 结束日期（范围查询）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "page": 1,
      "pageSize": 10,
      "total": 50,
      "items": [
        {
          "id": "string",
          "code": "string",
          "name": "string",
          "description": "string",
          "type": "string",
          "status": "string",
          "manager": {
            "id": "string",
            "realName": "string"
          },
          "team": [
            {
              "id": "string",
              "realName": "string",
              "role": "string"
            }
          ],
          "startDate": "string",
          "endDate": "string",
          "progress": 0,
          "createTime": "string"
        }
      ]
    },
    "message": "获取成功"
  }
  ```

##### 3.5.4.2 创建项目接口
- **接口路径**：`POST /api/v1/projects`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "name": "string",
    "description": "string",
    "type": "string",
    "managerId": "string",
    "teamMemberIds": ["string"],
    "startDate": "string",
    "endDate": "string",
    "estimatedHours": 400,
    "priority": "medium",
    "budget": 100000
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "code": "string",
      "name": "string"
    },
    "message": "创建成功"
  }
  ```

##### 3.5.4.3 获取项目详情接口
- **接口路径**：`GET /api/v1/projects/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "code": "string",
      "name": "string",
      "description": "string",
      "type": "string",
      "status": "string",
      "manager": {
        "id": "string",
        "realName": "string",
        "email": "string",
        "phone": "string"
      },
      "team": [
        {
          "id": "string",
          "realName": "string",
          "email": "string",
          "phone": "string",
          "role": "string"
        }
      ],
      "startDate": "string",
      "endDate": "string",
      "estimatedHours": 400,
      "actualHours": 350,
      "priority": "medium",
      "budget": 100000,
      "actualCost": 85000,
      "progress": 80,
      "attachments": [
        {
          "id": "string",
          "name": "string",
          "url": "string",
          "size": 10240,
          "uploadTime": "string"
        }
      ],
      "createTime": "string",
      "updateTime": "string"
    },
    "message": "获取成功"
  }
  ```

##### 3.5.4.4 更新项目接口
- **接口路径**：`PUT /api/v1/projects/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "name": "string",
    "description": "string",
    "type": "string",
    "status": "string",
    "managerId": "string",
    "teamMemberIds": ["string"],
    "endDate": "string",
    "priority": "high",
    "budget": 120000
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "更新成功"
  }
  ```

##### 3.5.4.5 删除项目接口
- **接口路径**：`DELETE /api/v1/projects/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "删除成功"
  }
  ```

##### 3.5.4.6 更新项目进度接口
- **接口路径**：`PUT /api/v1/projects/{id}/progress`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "progress": 85,
    "comment": "完成了主要功能模块开发"
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "进度更新成功"
  }
  ```

#### 3.5.5 资源管理器接口

##### 3.5.5.1 获取文件列表接口
- **接口路径**：`GET /api/v1/resources/files`
- **请求参数**：
  - `parentId`: 父文件夹ID（根目录为root）
  - `projectId`: 项目ID（可选）
  - `page`: 页码（默认1）
  - `pageSize`: 每页条数（默认20）
  - `type`: 文件类型筛选（document/image/video/other）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "page": 1,
      "pageSize": 20,
      "total": 100,
      "folders": [
        {
          "id": "string",
          "name": "string",
          "parentId": "string",
          "creator": {
            "id": "string",
            "realName": "string"
          },
          "createTime": "string",
          "updateTime": "string"
        }
      ],
      "files": [
        {
          "id": "string",
          "name": "string",
          "extension": "string",
          "size": 10240,
          "path": "string",
          "url": "string",
          "parentId": "string",
          "projectId": "string",
          "uploader": {
            "id": "string",
            "realName": "string"
          },
          "uploadTime": "string",
          "updateTime": "string"
        }
      ]
    },
    "message": "获取成功"
  }
  ```

##### 3.5.5.2 创建文件夹接口
- **接口路径**：`POST /api/v1/resources/folders`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "name": "string",
    "parentId": "string",
    "projectId": "string" // 可选
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "name": "string"
    },
    "message": "创建成功"
  }
  ```

##### 3.5.5.3 上传文件接口
- **接口路径**：`POST /api/v1/resources/upload`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：FormData
  - `file`: 文件对象
  - `parentId`: 父文件夹ID
  - `projectId`: 项目ID（可选）
  - `description`: 文件描述（可选）
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "name": "string",
      "url": "string",
      "size": 10240
    },
    "message": "上传成功"
  }
  ```

##### 3.5.5.4 文件下载接口
- **接口路径**：`GET /api/v1/resources/files/{id}/download`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：文件流

##### 3.5.5.5 删除文件/文件夹接口
- **接口路径**：`DELETE /api/v1/resources/{type}/{id}`
- **路径参数**：
  - `type`: 文件类型（file/folder）
  - `id`: 文件/文件夹ID
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "删除成功"
  }
  ```

##### 3.5.5.6 文件重命名接口
- **接口路径**：`PUT /api/v1/resources/files/{id}/rename`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "name": "string"
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "重命名成功"
  }
  ```

##### 3.5.5.7 移动文件/文件夹接口
- **接口路径**：`PUT /api/v1/resources/{type}/{id}/move`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "targetParentId": "string"
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "移动成功"
  }
  ```

##### 3.5.5.8 文件搜索接口
- **接口路径**：`GET /api/v1/resources/search`
- **请求参数**：
  - `keyword`: 搜索关键词
  - `projectId`: 项目ID（可选）
  - `type`: 文件类型筛选
  - `page`: 页码（默认1）
  - `pageSize`: 每页条数（默认20）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "page": 1,
      "pageSize": 20,
      "total": 50,
      "items": [
        {
          "id": "string",
          "name": "string",
          "type": "file", // file/folder
          "extension": "string",
          "size": 10240,
          "path": "string",
          "url": "string",
          "projectId": "string",
          "projectName": "string",
          "uploadTime": "string"
        }
      ]
    },
    "message": "搜索成功"
  }
  ```

#### 3.5.6 资料管理接口

##### 3.5.6.1 获取资料列表接口
- **接口路径**：`GET /api/v1/materials`
- **请求参数**：
  - `page`: 页码（默认1）
  - `pageSize`: 每页条数（默认15）
  - `keyword`: 搜索关键词（资料名称/编号）
  - `type`: 资料类型筛选（document/template/specification/standard）
  - `categoryId`: 分类ID
  - `tagIds`: 标签ID（多选）
  - `sortBy`: 排序字段（createTime/updateTime/downloadCount）
  - `sortOrder`: 排序方向（asc/desc）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "page": 1,
      "pageSize": 15,
      "total": 200,
      "items": [
        {
          "id": "string",
          "code": "string",
          "title": "string",
          "type": "string",
          "category": {
            "id": "string",
            "name": "string"
          },
          "tags": [
            {"id": "string", "name": "string"}
          ],
          "cover": "string",
          "summary": "string",
          "downloadCount": 100,
          "viewCount": 200,
          "creator": {
            "id": "string",
            "realName": "string"
          },
          "createTime": "string",
          "updateTime": "string"
        }
      ]
    },
    "message": "获取成功"
  }
  ```

##### 3.5.6.2 创建资料接口
- **接口路径**：`POST /api/v1/materials`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：FormData
  - `title`: 资料标题
  - `code`: 资料编号（可选）
  - `type`: 资料类型
  - `categoryId`: 分类ID
  - `tagIds`: 标签ID（多选）
  - `summary`: 资料摘要
  - `content`: 富文本内容（可选）
  - `cover`: 封面图片（可选）
  - `file`: 附件文件（可选）
  - `relatedProjectIds`: 关联项目ID（多选）
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "code": "string",
      "title": "string"
    },
    "message": "创建成功"
  }
  ```

##### 3.5.6.3 获取资料详情接口
- **接口路径**：`GET /api/v1/materials/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "code": "string",
      "title": "string",
      "type": "string",
      "category": {
        "id": "string",
        "name": "string"
      },
      "tags": [
        {"id": "string", "name": "string"}
      ],
      "summary": "string",
      "content": "string", // 富文本内容
      "cover": "string",
      "downloadCount": 100,
      "viewCount": 200,
      "attachments": [
        {
          "id": "string",
          "name": "string",
          "url": "string",
          "size": 10240,
          "uploadTime": "string"
        }
      ],
      "relatedProjects": [
        {
          "id": "string",
          "name": "string"
        }
      ],
      "creator": {
        "id": "string",
        "realName": "string"
      },
      "createTime": "string",
      "updateTime": "string"
    },
    "message": "获取成功"
  }
  ```

##### 3.5.6.4 更新资料接口
- **接口路径**：`PUT /api/v1/materials/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：FormData
  - `title`: 资料标题
  - `type`: 资料类型
  - `categoryId`: 分类ID
  - `tagIds`: 标签ID（多选）
  - `summary`: 资料摘要
  - `content`: 富文本内容（可选）
  - `cover`: 封面图片（可选）
  - `relatedProjectIds`: 关联项目ID（多选）
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "更新成功"
  }
  ```

##### 3.5.6.5 删除资料接口
- **接口路径**：`DELETE /api/v1/materials/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "删除成功"
  }
  ```

##### 3.5.6.6 资料附件上传接口
- **接口路径**：`POST /api/v1/materials/{id}/attachments`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：FormData
  - `file`: 文件对象
  - `description`: 文件描述（可选）
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "name": "string",
      "url": "string",
      "size": 10240
    },
    "message": "上传成功"
  }
  ```

##### 3.5.6.7 资料附件删除接口
- **接口路径**：`DELETE /api/v1/materials/{id}/attachments/{attachmentId}`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "删除成功"
  }
  ```

##### 3.5.6.8 获取资料分类接口
- **接口路径**：`GET /api/v1/materials/categories`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": [
      {
        "id": "string",
        "name": "string",
        "parentId": "string",
        "children": [
          {
            "id": "string",
            "name": "string"
          }
        ]
      }
    ],
    "message": "获取成功"
  }
  ```

#### 3.5.7 销售与统计接口

##### 3.5.7.1 获取销售订单列表接口
- **接口路径**：`GET /api/v1/sales/orders`
- **请求参数**：
  - `page`: 页码（默认1）
  - `pageSize`: 每页条数（默认15）
  - `keyword`: 搜索关键词（客户名称/订单编号）
  - `status`: 订单状态筛选
  - `startDate`: 开始日期（范围查询）
  - `endDate`: 结束日期（范围查询）
  - `salesmanId`: 销售人员ID
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "page": 1,
      "pageSize": 15,
      "total": 100,
      "items": [
        {
          "id": "string",
          "orderNumber": "string",
          "customer": {
            "id": "string",
            "name": "string",
            "contact": "string",
            "phone": "string"
          },
          "salesman": {
            "id": "string",
            "realName": "string"
          },
          "totalAmount": 100000,
          "status": "string",
          "createTime": "string",
          "paymentStatus": "string",
          "deliveryStatus": "string"
        }
      ]
    },
    "message": "获取成功"
  }
  ```

##### 3.5.7.2 创建销售订单接口
- **接口路径**：`POST /api/v1/sales/orders`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "customerId": "string",
    "salesmanId": "string",
    "items": [
      {
        "productId": "string",
        "productName": "string",
        "quantity": 10,
        "unitPrice": 5000,
        "totalPrice": 50000
      }
    ],
    "totalAmount": 100000,
    "paymentMethod": "string",
    "deliveryAddress": "string",
    "remark": "string"
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "orderNumber": "string"
    },
    "message": "创建成功"
  }
  ```

##### 3.5.7.3 获取销售订单详情接口
- **接口路径**：`GET /api/v1/sales/orders/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "orderNumber": "string",
      "customer": {
        "id": "string",
        "name": "string",
        "contact": "string",
        "phone": "string",
        "address": "string"
      },
      "salesman": {
        "id": "string",
        "realName": "string"
      },
      "items": [
        {
          "id": "string",
          "productId": "string",
          "productName": "string",
          "quantity": 10,
          "unitPrice": 5000,
          "totalPrice": 50000
        }
      ],
      "totalAmount": 100000,
      "paymentMethod": "string",
      "paymentStatus": "string",
      "deliveryAddress": "string",
      "deliveryStatus": "string",
      "remark": "string",
      "createTime": "string",
      "updateTime": "string"
    },
    "message": "获取成功"
  }
  ```

##### 3.5.7.4 更新销售订单状态接口
- **接口路径**：`PUT /api/v1/sales/orders/{id}/status`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "status": "string",
    "paymentStatus": "string",
    "deliveryStatus": "string",
    "remark": "string"
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "更新成功"
  }
  ```

##### 3.5.7.5 获取销售统计数据接口
- **接口路径**：`GET /api/v1/statistics/sales`
- **请求参数**：
  - `startDate`: 开始日期
  - `endDate`: 结束日期
  - `type`: 统计类型（daily/monthly/quarterly/yearly）
  - `salesmanId`: 销售人员ID（可选）
  - `category`: 产品分类（可选）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "totalSales": 1000000,
      "totalOrders": 50,
      "totalProducts": 500,
      "averageOrderValue": 20000,
      "salesTrend": [
        {
          "date": "2023-01",
          "amount": 100000,
          "orders": 5
        }
      ],
      "topSalesmen": [
        {
          "id": "string",
          "name": "string",
          "amount": 500000,
          "orders": 25
        }
      ],
      "topProducts": [
        {
          "id": "string",
          "name": "string",
          "quantity": 100,
          "amount": 200000
        }
      ]
    },
    "message": "获取成功"
  }
  ```

##### 3.5.7.6 获取项目统计数据接口
- **接口路径**：`GET /api/v1/statistics/projects`
- **请求参数**：
  - `startDate`: 开始日期
  - `endDate`: 结束日期
  - `status`: 项目状态（可选）
  - `managerId`: 项目经理ID（可选）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "totalProjects": 20,
      "projectsByStatus": [
        {"status": "planning", "count": 3},
        {"status": "in_progress", "count": 10},
        {"status": "completed", "count": 5},
        {"status": "delayed", "count": 2}
      ],
      "averageCompletionRate": 65,
      "overdueProjects": 2,
      "projectTimeDistribution": [
        {
          "month": "2023-01",
          "newProjects": 2,
          "completedProjects": 1
        }
      ]
    },
    "message": "获取成功"
  }
  ```

#### 3.5.8 系统管理接口

##### 3.5.8.1 获取部门列表接口
- **接口路径**：`GET /api/v1/system/departments`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": [
      {
        "id": "string",
        "name": "string",
        "parentId": "string",
        "leaderId": "string",
        "leaderName": "string",
        "description": "string",
        "createTime": "string",
        "children": [
          {
            "id": "string",
            "name": "string",
            "parentId": "string",
            "children": []
          }
        ]
      }
    ],
    "message": "获取成功"
  }
  ```

##### 3.5.8.2 创建部门接口
- **接口路径**：`POST /api/v1/system/departments`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "name": "string",
    "parentId": "string",
    "leaderId": "string",
    "description": "string"
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "name": "string"
    },
    "message": "创建成功"
  }
  ```

##### 3.5.8.3 更新部门接口
- **接口路径**：`PUT /api/v1/system/departments/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "name": "string",
    "parentId": "string",
    "leaderId": "string",
    "description": "string"
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "更新成功"
  }
  ```

##### 3.5.8.4 删除部门接口
- **接口路径**：`DELETE /api/v1/system/departments/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "删除成功"
  }
  ```

##### 3.5.8.5 获取角色列表接口
- **接口路径**：`GET /api/v1/system/roles`
- **请求参数**：
  - `page`: 页码（默认1）
  - `pageSize`: 每页条数（默认15）
  - `keyword`: 搜索关键词（角色名称）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "page": 1,
      "pageSize": 15,
      "total": 20,
      "items": [
        {
          "id": "string",
          "name": "string",
          "code": "string",
          "description": "string",
          "permissionCount": 10,
          "userCount": 5,
          "createTime": "string"
        }
      ]
    },
    "message": "获取成功"
  }
  ```

##### 3.5.8.6 创建角色接口
- **接口路径**：`POST /api/v1/system/roles`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "name": "string",
    "code": "string",
    "description": "string",
    "permissionIds": ["string"]
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "name": "string"
    },
    "message": "创建成功"
  }
  ```

##### 3.5.8.7 获取角色详情接口
- **接口路径**：`GET /api/v1/system/roles/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "name": "string",
      "code": "string",
      "description": "string",
      "permissions": [
        {
          "id": "string",
          "name": "string",
          "code": "string",
          "category": "string"
        }
      ],
      "createTime": "string",
      "updateTime": "string"
    },
    "message": "获取成功"
  }
  ```

##### 3.5.8.8 更新角色权限接口
- **接口路径**：`PUT /api/v1/system/roles/{id}/permissions`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "permissionIds": ["string"]
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "更新成功"
  }
  ```

##### 3.5.8.9 获取权限列表接口
- **接口路径**：`GET /api/v1/system/permissions`
- **请求参数**：
  - `category`: 权限分类（可选）
  - `type`: 权限类型（menu/api/button，可选）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": [
      {
        "id": "string",
        "name": "string",
        "code": "string",
        "type": "string",
        "category": "string",
        "url": "string",
        "method": "string",
        "parentId": "string",
        "sort": 1,
        "createTime": "string",
        "children": [
          {
            "id": "string",
            "name": "string",
            "code": "string"
          }
        ]
      }
    ],
    "message": "获取成功"
  }
  ```

##### 3.5.8.10 获取系统字典接口
- **接口路径**：`GET /api/v1/system/dictionaries`
- **请求参数**：
  - `type`: 字典类型（可选）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": [
      {
        "type": "string",
        "name": "string",
        "items": [
          {
            "value": "string",
            "label": "string",
            "color": "string",
            "sort": 1
          }
        ]
      }
    ],
    "message": "获取成功"
  }
  ```

##### 3.5.8.11 获取系统日志接口
- **接口路径**：`GET /api/v1/system/logs`
- **请求参数**：
  - `page`: 页码（默认1）
  - `pageSize`: 每页条数（默认20）
  - `username`: 用户名（可选）
  - `operation`: 操作类型（可选）
  - `ip`: IP地址（可选）
  - `startTime`: 开始时间（可选）
  - `endTime`: 结束时间（可选）
  - `success`: 是否成功（可选）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "page": 1,
      "pageSize": 20,
      "total": 1000,
      "items": [
        {
          "id": "string",
          "username": "string",
          "operation": "string",
          "module": "string",
          "ip": "string",
          "userAgent": "string",
          "params": "string",
          "result": "string",
          "success": true,
          "costTime": 100,
          "createTime": "string"
        }
      ]
    },
    "message": "获取成功"
  }
  ```

##### 3.5.8.12 获取系统配置接口
- **接口路径**：`GET /api/v1/system/configs`
- **请求参数**：
  - `keys`: 配置键（可选，多选）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": [
      {
        "key": "string",
        "value": "string",
        "name": "string",
        "description": "string",
        "type": "string"
      }
    ],
    "message": "获取成功"
  }
  ```

##### 3.5.8.13 更新系统配置接口
- **接口路径**：`PUT /api/v1/system/configs`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  [
    {
      "key": "string",
      "value": "string"
    }
  ]
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "更新成功"
  }
  ```

#### 3.5.9 标签管理接口

##### 3.5.9.1 获取标签列表接口
- **接口路径**：`GET /api/v1/system/tags`
- **请求参数**：
  - `page`: 页码（默认1）
  - `pageSize`: 每页条数（默认20）
  - `keyword`: 搜索关键词（标签名称）
  - `type`: 标签类型（product/skill，可选）
  - `category`: 标签分类（可选）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "page": 1,
      "pageSize": 20,
      "total": 50,
      "items": [
        {
          "id": "string",
          "name": "string",
          "description": "string",
          "type": "string",
          "category": "string",
          "color": "string",
          "useCount": 10
        }
      ]
    },
    "message": "获取成功"
  }
  ```

##### 3.5.9.2 创建标签接口
- **接口路径**：`POST /api/v1/system/tags`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "name": "string",
    "description": "string",
    "type": "string",
    "category": "string",
    "color": "string"
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "id": "string",
      "name": "string"
    },
    "message": "创建成功"
  }
  ```

##### 3.5.9.3 更新标签接口
- **接口路径**：`PUT /api/v1/system/tags/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "name": "string",
    "description": "string",
    "category": "string",
    "color": "string"
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "更新成功"
  }
  ```

##### 3.5.9.4 删除标签接口
- **接口路径**：`DELETE /api/v1/system/tags/{id}`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "删除成功"
  }
  ```

##### 3.5.9.5 获取标签分类接口
- **接口路径**：`GET /api/v1/system/tags/categories`
- **请求参数**：
  - `type`: 标签类型（product/skill，可选）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": [
      {
        "name": "string",
        "count": 10
      }
    ],
    "message": "获取成功"
  }
  ```

#### 3.5.10 成品标签管理接口

##### 3.5.10.1 获取成品标签列表接口
- **接口路径**：`GET /api/v1/products/{id}/tags`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": [
      {
        "id": "string",
        "name": "string",
        "category": "string",
        "color": "string"
      }
    ],
    "message": "获取成功"
  }
  ```

##### 3.5.10.2 添加成品标签接口
- **接口路径**：`POST /api/v1/products/{id}/tags`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "tagIds": ["string"]
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "添加成功"
  }
  ```

##### 3.5.10.3 移除成品标签接口
- **接口路径**：`DELETE /api/v1/products/{id}/tags`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "tagIds": ["string"]
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "移除成功"
  }
  ```

##### 3.5.10.4 批量更新成品标签接口
- **接口路径**：`PUT /api/v1/products/{id}/tags`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "tagIds": ["string"]
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "更新成功"
  }
  ```

#### 3.5.11 用户技能标签管理接口

##### 3.5.11.1 获取用户技能标签列表接口
- **接口路径**：`GET /api/v1/users/{id}/skill-tags`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": [
      {
        "id": "string",
        "name": "string",
        "category": "string",
        "color": "string",
        "proficiencyLevel": 4,
        "createdBy": "string",
        "createdByName": "string"
      }
    ],
    "message": "获取成功"
  }
  ```

##### 3.5.11.2 添加用户技能标签接口
- **接口路径**：`POST /api/v1/users/{id}/skill-tags`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "tagIds": ["string"],
    "proficiencyLevel": 4
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "添加成功"
  }
  ```

##### 3.5.11.3 更新用户技能标签熟练度接口
- **接口路径**：`PUT /api/v1/users/{id}/skill-tags/{tagId}/proficiency`
- **请求头**：`Authorization: Bearer {token}`
- **请求体**：
  ```json
  {
    "proficiencyLevel": 5
  }
  ```
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "更新成功"
  }
  ```

##### 3.5.11.4 移除用户技能标签接口
- **接口路径**：`DELETE /api/v1/users/{id}/skill-tags/{tagId}`
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": null,
    "message": "移除成功"
  }
  ```

##### 3.5.11.5 获取标签相关用户接口
- **接口路径**：`GET /api/v1/system/tags/{id}/users`
- **请求参数**：
  - `page`: 页码（默认1）
  - `pageSize`: 每页条数（默认20）
  - `minProficiency`: 最低熟练度（可选）
- **请求头**：`Authorization: Bearer {token}`
- **响应**：
  ```json
  {
    "code": 0,
    "data": {
      "page": 1,
      "pageSize": 20,
      "total": 15,
      "items": [
        {
          "id": "string",
          "username": "string",
          "realName": "string",
          "department": {
            "id": "string",
            "name": "string"
          },
          "position": "string",
          "proficiencyLevel": 4
        }
      ]
    },
    "message": "获取成功"
  }
  ```

### 3.6 开发规范

#### 3.6.1 命名规范
- **变量命名**
  - 后端（Node.js/Java）：小驼峰命名法，如 `userName`、`projectId`
  - 前端（JavaScript/TypeScript）：小驼峰命名法，如 `isActive`、`totalCount`
  - 常量：全大写，下划线分隔，如 `MAX_UPLOAD_SIZE`、`DEFAULT_PAGE_SIZE`
- **函数/方法命名**
  - 动词+名词结构，小驼峰命名，如 `createProject()`、`getUserInfo()`
  - 查询类方法：`get`/`find` 开头，如 `getProjects()`、`findUserById()`
  - 更新类方法：`update` 开头，如 `updateProjectStatus()`
  - 删除类方法：`delete`/`remove` 开头，如 `deleteFile()`
- **类/组件命名**
  - 大驼峰命名法（PascalCase），如 `UserController`、`ProjectService`
  - React组件：`ProjectList`、`UserProfile`
- **文件命名**
  - 后端：小驼峰或短横线分隔，如 `userService.js` 或 `project-management.js`
  - 前端：组件文件使用大驼峰，其他使用小驼峰，如 `ProjectList.jsx`、`apiClient.js`
  - 工具文件：`utils.js`、`dateHelper.js`
- **数据库命名**
  - 表名：小写，下划线分隔，如 `user_info`、`project_tasks`
  - 字段名：小写，下划线分隔，如 `user_id`、`create_time`
  - 索引名：`idx_表名_字段名`，如 `idx_user_email`
- **接口路由命名**
  - RESTful风格，小写，短横线分隔，如 `/api/users/profile`、`/api/projects/:id`
  - 动词使用HTTP方法表示，路径使用名词复数
- **注释命名**
  - 类/函数注释：完整描述功能、参数、返回值
  - 变量注释：说明用途和数据类型
  - 复杂逻辑处添加行注释说明

#### 3.6.2 代码风格
- **缩进和格式**
  - 使用2个空格进行缩进（禁止使用Tab）
  - 大括号使用K&R风格（左大括号与语句同行）
  - 每行代码长度不超过120个字符
  - 空行使用：类/函数定义前后空2行，代码块之间空1行
- **JavaScript/TypeScript代码风格**
  - 优先使用const/let，避免使用var
  - 使用箭头函数简化回调
  - 字符串统一使用单引号
  - 结束语句必须使用分号
  - 对象字面量使用简写属性和方法
  - 解构赋值简化变量声明
- **Java/后端代码风格**
  - 类成员顺序：静态变量、实例变量、构造函数、方法
  - 方法体不超过100行
  - 避免深度嵌套（最多3层）
  - 异常处理使用try-catch，避免空catch块
- **SQL代码风格**
  - 关键字大写：SELECT、FROM、WHERE
  - 表名和字段名使用反引号包裹
  - 复杂查询使用缩进和换行
  - 避免使用SELECT *，明确指定需要的字段
- **注释风格**
  - 类/函数注释使用JSDoc格式
  - 行注释使用//，与代码保持1个空格距离
  - 复杂业务逻辑添加详细注释说明
  - 禁止使用TODO注释在提交代码时
- **React/Vue组件风格**
  - 组件职责单一，避免过度复杂
  - Props使用TypeScript/PropTypes进行类型验证
  - 状态管理清晰，避免过度使用全局状态
  - 生命周期方法按顺序组织

## 4. 详细功能设计

### 4.1 权限管理模块详细设计

#### 4.1.1 RBAC权限模型实现
- **角色定义**：
  - 预设六级角色体系：超级管理员、高级管理员、中级管理员、普通管理员、普通员工、试岗员工
  - 支持基于预设角色的自定义角色创建和修改
  - 每个角色可关联多个权限点
- **权限继承**：
  - 实现层级继承：下级角色自动继承上级角色的基础权限（试岗员工→普通员工→普通管理员→中级管理员→高级管理员→超级管理员）
  - 支持显式权限覆盖（可针对特定角色移除某些继承权限）
  - 权限组合支持逻辑或（OR）和逻辑与（AND）关系
- **权限缓存**：
  - 用户权限缓存到Redis，减少数据库查询
  - 权限变更时自动清理相关缓存
  - 缓存失效策略：基于TTL和手动触发双重机制
- **权限验证**：
  - 支持基于角色的验证和基于权限点的验证
  - 支持数据级权限控制（如只能查看自己部门的数据）

#### 4.1.2 权限验证中间件
```javascript
// 使用统一权限中间件
function requirePermission(permission) {
  return async (req, res, next) => {
    try {
      // 先检查缓存
      const cachedPermission = await cacheService.getPermission(req.user.id, permission);
      if (cachedPermission !== null) {
        cachedPermission ? next() : res.status(403).json({ code: 1001, message: '权限不足' });
        return;
      }
      
      // 缓存未命中时查询数据库
      const hasPermission = await permissionService.checkPermission(
        req.user.id, 
        permission
      );
      
      // 更新缓存
      await cacheService.setPermission(req.user.id, permission, hasPermission);
      
      if (hasPermission) {
        next();
      } else {
        res.status(403).json({ code: 1001, message: '权限不足' });
      }
    } catch (error) {
      next(error);
    }
  };
}

// API路由中使用
router.get('/sensitive-data', requirePermission('data.view'), controller.getData);
```

#### 4.1.3 批量权限分配功能
- **基于角色模板**：预设常用权限模板
- **批量用户选择**：支持多条件筛选用户
- **权限预览**：分配前显示权限变更内容
- **操作日志**：记录详细的权限变更历史

### 4.2 项目管理模块详细设计

#### 4.2.1 状态机模式项目状态管理
- **状态定义**：需求分析、设计阶段、开发阶段、测试阶段、部署阶段、已完成、已暂停
- **状态转换规则**：
  - 明确定义哪些状态可以互相转换
  - 转换需要满足的前置条件
  - 转换权限的精细控制
- **状态转换实现**：
  ```javascript
  class ProjectStateMachine {
    constructor(project) {
      this.project = project;
    }
    
    async transitionTo(newState, userId) {
      // 验证状态转换是否合法
      if (!this._isValidTransition(newState)) {
        throw new Error(`Invalid state transition: ${this.project.status} -> ${newState}`);
      }
      
      // 验证权限
      const hasPermission = await this._checkTransitionPermission(userId, newState);
      if (!hasPermission) {
        throw new Error('No permission for this state transition');
      }
      
      // 执行状态转换前钩子
      await this._beforeTransition(newState);
      
      // 更新状态
      this.project.status = newState;
      await this.project.save();
      
      // 记录状态变更历史
      await this._logStateChange(userId);
      
      // 执行状态转换后钩子（触发通知等）
      await this._afterTransition(newState);
      
      return this.project;
    }
    
    // 其他辅助方法...
  }
  ```

#### 4.2.2 项目高级搜索功能
- **多条件组合搜索**：
  - 关键词搜索：项目名称、描述
  - 时间范围筛选：创建时间、更新时间
  - 状态筛选：多状态并列
  - 负责人筛选：支持团队筛选
- **搜索优化**：
  - 使用索引加速搜索
  - 实现搜索结果排序
  - 支持搜索历史记录

#### 4.2.3 项目批量操作
- **批量状态更新**：支持条件筛选后批量更新
- **批量成员管理**：同时分配或移除多个项目的成员
- **批量导出**：按条件导出项目信息
- **批量归档**：自动归档完成的项目

### 4.3 人员管理模块详细设计

#### 4.3.1 试用期管理
- **自动计算试用期截止日期**：根据入职日期和试用期时长（如3个月）自动计算
- **试用期到期前自动提醒**：系统在试用期结束前一周自动发送提醒给HR和直接上级
- **转正申请和审批流程**：员工提交转正申请，经过审批流程（直接上级、部门负责人、HR）后更新员工状态

#### 4.3.2 员工信息批量操作
- **批量导入**：支持通过Excel模板批量导入员工信息，包括必填字段验证和数据格式检查
- **批量导出**：根据筛选条件导出员工列表到Excel
- **批量分配角色和权限**：在员工列表中批量选择员工，分配角色或调整权限
- **批量更新员工状态**：如批量将试用期员工转正，或批量处理离职

#### 4.3.3 员工离职流程
- **生成交接清单**：系统自动生成该员工负责的项目、资料等交接清单
- **权限回收**：离职流程启动后，立即回收系统权限
- **项目交接**：将员工负责的项目转移给接替者
- **资料交接**：将员工上传的资料转移给接替者或指定人员
- **更新员工状态**：标记为"已离职"，并记录离职日期
- **记录离职信息**：记录离职原因、交接情况等

### 4.4 资料管理模块详细设计

#### 4.4.1 压缩包资料上传功能（工程师专属）
- **功能概述**：专为工程师设计的批量资料上传功能，支持上传zip/rar等压缩包，系统自动解压并创建相应的文件结构
- **技术实现**：
  - 使用Node.js的archiver和unzipper库处理压缩文件
  - 前端使用拖拽上传组件，支持大文件分片上传
  - 后端实现异步解压处理，避免阻塞请求
- **文件结构自动识别**：
  - 自动识别常见工程文件类型（如.c, .h, .ino, .py等）
  - 对解压后的文件进行分类和索引
  - 支持自动生成项目结构预览图
- **安全处理**：
  - 病毒扫描：对上传的压缩包进行恶意文件检测
  - 文件类型过滤：限制允许解压的文件类型
  - 路径遍历防护：防止解压路径攻击
- **代码实现示例**：
  ```javascript
  // 后端解压处理函数
  async function handleCompressedUpload(file, projectId) {
    try {
      const tempDir = path.join(os.tmpdir(), `upload_${uuid.v4()}`);
      const extractedDir = path.join(tempDir, 'extracted');
      
      // 确保临时目录存在
      await fs.mkdir(extractedDir, { recursive: true });
      
      // 保存上传的文件
      await fs.promises.writeFile(path.join(tempDir, file.originalname), file.buffer);
      
      // 根据文件类型解压
      if (file.originalname.endsWith('.zip')) {
        await extractZip(path.join(tempDir, file.originalname), { dir: extractedDir });
      } else if (file.originalname.endsWith('.rar')) {
        // 使用rar解压工具
      }
      
      // 扫描解压后的文件
      const files = await recursiveReadDir(extractedDir);
      
      // 批量上传文件
      const uploadPromises = files.map(async (filePath) => {
        const relativePath = path.relative(extractedDir, filePath);
        const fileContent = await fs.promises.readFile(filePath);
        
        return fileStorage.upload({
          buffer: fileContent,
          originalname: relativePath,
          projectId: projectId
        });
      });
      
      const results = await Promise.all(uploadPromises);
      
      // 清理临时文件
      await fs.promises.rm(tempDir, { recursive: true, force: true });
      
      return {
        success: true,
        uploadedFiles: results.length,
        files: results
      };
    } catch (error) {
      logger.error('压缩包处理失败:', error);
      throw new Error('压缩包处理失败');
    }
  }
  ```
- **权限控制**：
  - 仅工程师及以上角色可使用此功能
  - 上传后文件权限继承自项目权限
- **用户体验优化**：
  - 上传进度实时显示
  - 解压过程后台处理，不阻塞用户操作
  - 上传完成后自动刷新文件列表

#### 4.4.2 分布式文件存储实现
- **存储抽象层**：
  ```javascript
  // 文件存储抽象接口
  class FileStorage {
    async upload(file, metadata) {}
    async download(fileId) {}
    async delete(fileId) {}
    async getMetadata(fileId) {}
  }
  
  // 本地文件系统实现
  class LocalFileStorage extends FileStorage {}
  
  // MinIO对象存储实现
  class MinIOStorage extends FileStorage {}
  
  // 工厂方法创建合适的存储实例
  function createStorage(config) {
    switch (config.type) {
      case 'local': return new LocalFileStorage(config);
      case 'minio': return new MinIOStorage(config);
      default: throw new Error('Unsupported storage type');
    }
  }
  ```
- **大文件分块上传**：
  - 支持断点续传
  - 并行上传多个块
  - 服务端合并处理
- **文件去重机制**：
  - 基于内容哈希的文件去重
  - 节省存储空间

#### 4.4.3 资料版本控制
- **版本号规则**：采用语义化版本号（如1.0.0），每次更新根据变更类型（大版本、小版本、修订）自动升级版本号
- **历史版本查看**：可以查看每个资料的历史版本列表，包括版本号、上传时间、上传者、版本说明
- **版本回滚**：可以将资料回滚到任意历史版本，回滚后生成新的版本记录

#### 4.4.4 资料全文搜索实现
- **索引构建**：
  - 使用Elasticsearch或PostgreSQL全文搜索
  - 对Office文档、PDF进行文本提取和索引
- **搜索优化**：
  - 搜索结果相关性排序
  - 关键词高亮显示
  - 搜索建议和自动补全

### 4.5 项目修改提示服务实现
- **功能概述**：实时监控项目关键信息的变更，自动通知相关项目成员，确保团队信息同步和协作效率
- **监控内容**：
  - 项目基本信息变更（名称、描述、截止日期等）
  - 项目状态变更（进度、优先级、状态等）
  - 项目成员变动（添加、移除成员，角色变更）
  - 项目文档和附件更新
  - 重要里程碑和任务更新
- **通知机制**：
  - 站内信通知：系统内弹窗和消息中心提醒
  - 邮件通知：重要变更发送邮件提醒
  - 移动端推送：支持移动设备消息推送
  - 桌面通知：支持浏览器桌面通知
- **智能过滤机制**：
  - 根据用户角色和关注设置过滤通知
  - 支持用户自定义接收哪些类型的通知
  - 相同类型的频繁通知进行合并
- **技术实现**：
  - 基于事件驱动架构
  - 使用发布-订阅模式处理通知分发
  - Redis实现消息队列和通知缓存
- **代码实现示例**：
  ```javascript
  // 项目修改事件发布器
  class ProjectEventPublisher {
    constructor(eventBus) {
      this.eventBus = eventBus;
    }
    
    async publishProjectUpdate(projectId, changes, updatedBy) {
      // 获取项目信息和相关成员
      const project = await projectService.getProject(projectId, { includeMembers: true });
      
      // 创建事件数据
      const eventData = {
        projectId: project.id,
        projectName: project.name,
        changes: changes,
        updatedBy: updatedBy,
        timestamp: new Date().toISOString()
      };
      
      // 发布事件到消息总线
      await this.eventBus.publish('project.updated', eventData);
      
      // 记录变更日志
      await changeLogService.createChangeLog({
        entityType: 'project',
        entityId: projectId,
        changes: changes,
        operatorId: updatedBy.id
      });
      
      return eventData;
    }
  }
  
  // 通知处理器
  class NotificationHandler {
    constructor(userPreferencesService, notificationService) {
      this.userPreferencesService = userPreferencesService;
      this.notificationService = notificationService;
    }
    
    async handleProjectUpdate(eventData) {
      // 获取需要通知的用户
      const usersToNotify = await this.getUserToNotify(eventData);
      
      // 为每个用户创建通知
      for (const user of usersToNotify) {
        // 检查用户通知偏好
        const preferences = await this.userPreferencesService.getUserPreferences(user.id);
        
        // 根据变更类型和用户偏好决定通知方式
        const notificationTypes = this.determineNotificationTypes(eventData.changes, preferences);
        
        // 创建通知
        await this.notificationService.createNotification({
          userId: user.id,
          type: 'project_update',
          title: `项目更新提醒: ${eventData.projectName}`,
          content: this.formatNotificationContent(eventData),
          relatedEntity: {
            type: 'project',
            id: eventData.projectId
          },
          notificationTypes: notificationTypes
        });
      }
    }
  }
  ```
- **性能优化**：
  - 批量发送通知减少数据库操作
  - 通知内容模板化缓存
  - 异步处理通知发送
- **通知管理**：
  - 已读/未读状态管理
  - 通知历史记录查询
  - 一键标记已读和批量删除功能

### 4.6 安全与性能优化

#### 4.6.1 API速率限制实现
```javascript
// 基于令牌桶算法的速率限制中间件
function rateLimiter(options) {
  const { maxRequests, windowMs } = options;
  
  return async (req, res, next) => {
    const key = req.user ? `user:${req.user.id}` : `ip:${req.ip}`;
    
    // 获取当前令牌数量
    const currentTokens = await redisClient.get(key) || maxRequests;
    
    if (currentTokens <= 0) {
      return res.status(429).json({
        code: 429,
        message: '请求过于频繁，请稍后再试'
      });
    }
    
    // 减少令牌并设置过期时间
    await redisClient.decr(key);
    if (currentTokens == maxRequests) {
      await redisClient.expire(key, windowMs / 1000);
    }
    
    // 设置剩余请求头
    res.setHeader('X-RateLimit-Remaining', currentTokens - 1);
    next();
  };
}

// 应用到API路由
app.use('/api', rateLimiter({ maxRequests: 100, windowMs: 60000 }));
```

#### 4.6.2 缓存策略
- **多级缓存架构**：
  - L1：内存缓存（Node.js内存）
  - L2：分布式缓存（Redis）
- **缓存一致性**：
  - 数据变更时主动失效相关缓存
  - 使用缓存标签批量失效
- **缓存预热**：
  - 系统启动时加载热点数据
  - 定时更新缓存数据

### 4.7 错误处理与日志标准化

#### 4.7.1 全局错误处理中间件
```javascript
// 统一错误处理中间件
function errorHandler(err, req, res, next) {
  // 日志记录
  logger.error({
    message: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
    userId: req.user?.id || 'unauthenticated',
    timestamp: new Date().toISOString()
  });
  
  // 标准化错误响应
  const errorResponse = {
    code: err.code || 500,
    message: err.message || '服务器内部错误',
    // 仅在开发环境返回详细错误信息
    details: process.env.NODE_ENV === 'development' ? err.details : undefined
  };
  
  // 发送错误响应
  res.status(errorResponse.code >= 400 && errorResponse.code < 600 ? errorResponse.code : 500)
     .json(errorResponse);
}

// 应用错误处理中间件
app.use(errorHandler);
```

#### 4.7.2 统一事务管理
```javascript
// 声明式事务装饰器
function Transactional() {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = async function(...args) {
      const connection = await database.getConnection();
      try {
        await connection.beginTransaction();
        // 注入事务连接到方法上下文
        this.transaction = connection;
        const result = await originalMethod.apply(this, args);
        await connection.commit();
        return result;
      } catch (error) {
        await connection.rollback();
        // 添加上下文信息
        error.context = { method: propertyKey, args: args.map(arg => 
          typeof arg === 'object' ? JSON.stringify(arg) : arg
        )};
        throw error;
      } finally {
        delete this.transaction;
        connection.release();
      }
    };
    return descriptor;
  };
}

// 使用示例
class ProjectService {
  @Transactional()
  async createProject(projectData, userId) {
    // 这里的操作都在事务中执行
    const project = await this.projectRepository.create(projectData);
    await this.projectLogRepository.logCreation(project.id, userId);
    return project;
  }
}
```

#### 4.7.3 全局错误码规范
- **系统错误码**：
  - 1001: 权限不足
  - 1002: 资源不存在
  - 1003: 参数错误
  - 1004: 数据库错误
  - 1005: 文件操作错误
- **业务错误码**：
  - 2001: 项目状态转换错误
  - 2002: 审批流程错误
  - 2003: 用户状态错误

### 4.8 系统部署与维护

#### 4.8.1 部署架构
- **单机部署**：适合小型团队
- **集群部署**：高可用配置
- **容器化部署**：Docker + Docker Compose

#### 4.8.2 数据备份与恢复
- **自动备份策略**：
  - 数据库定时备份
  - 文件系统增量备份
- **异地备份**：防范灾难性数据丢失
- **恢复演练**：定期测试备份恢复流程

### 4.9 数据导入导出模块设计

#### 4.9.1 批量数据导入功能
- **功能概述**：支持Excel、CSV等格式的批量数据导入，实现用户、项目、产品等核心数据的快速初始化和批量更新
- **支持的数据类型**：
  - 用户数据导入（员工信息、部门关系、角色权限）
  - 项目数据导入（项目基本信息、项目成员、项目阶段）
  - 产品数据导入（产品信息、规格参数、库存信息）
  - 资料数据导入（文档元数据、分类关系）
  - 销售订单导入（订单信息、订单明细）
- **技术架构**：
  - 前端：拖拽上传组件，支持模板下载、数据预览
  - 后端：流式处理大文件，异步任务处理导入流程
  - 存储：临时文件存储，Redis任务队列，数据库批量写入
- **导入流程**：
  1. **模板下载**：提供标准化Excel/CSV模板
  2. **文件上传**：支持拖拽上传，文件格式验证
  3. **数据预览**：上传后显示前N行数据供用户确认
  4. **字段映射**：用户可调整列与系统字段的映射关系
  5. **数据验证**：格式验证、业务规则验证、重复数据检测
  6. **批量导入**：异步执行导入任务
  7. **结果反馈**：导入成功/失败统计，错误详情下载
- **核心代码实现**：
  ```javascript
  // Excel解析与导入服务
  class ExcelImportService {
    constructor(importTemplateService, validationService, dataProcessor) {
      this.importTemplateService = importTemplateService;
      this.validationService = validationService;
      this.dataProcessor = dataProcessor;
    }
    
    async importData(file, importType, userId) {
      try {
        // 1. 创建导入任务记录
        const importTask = await this.createImportTask(importType, userId);
        
        // 2. 获取导入模板定义
        const template = await this.importTemplateService.getTemplate(importType);
        
        // 3. 解析Excel文件
        const parsedData = await this.parseExcelFile(file, template);
        
        // 4. 数据验证
        const validationResult = await this.validationService.validateData(
          parsedData, 
          template.validationRules,
          importTask.id
        );
        
        // 5. 记录验证结果
        if (validationResult.hasErrors) {
          await this.updateImportTask(importTask.id, {
            status: 'validation_failed',
            errorCount: validationResult.errorCount,
            errorDetails: validationResult.errors
          });
          return {
            success: false,
            taskId: importTask.id,
            errors: validationResult.errors
          };
        }
        
        // 6. 异步执行批量导入
        await this.dataProcessor.processBatchImport(
          validationResult.validData,
          template,
          importTask.id,
          userId
        );
        
        // 7. 更新任务状态为处理中
        await this.updateImportTask(importTask.id, { status: 'processing' });
        
        return {
          success: true,
          taskId: importTask.id,
          totalCount: parsedData.length
        };
      } catch (error) {
        console.error('Import error:', error);
        throw new ImportException('导入过程中发生错误', error);
      }
    }
    
    async parseExcelFile(file, template) {
      // 使用stream处理大文件
      const workbook = await exceljs.stream.xlsx.readFile(file.path);
      const worksheet = workbook.getWorksheet(1);
      
      const results = [];
      const headers = {};
      
      // 解析表头
      worksheet.getRow(template.headerRowIndex).eachCell((cell, colNumber) => {
        headers[colNumber] = cell.value;
      });
      
      // 解析数据行
      worksheet.eachRow((row, rowNumber) => {
        if (rowNumber <= template.headerRowIndex) return;
        
        const rowData = {};
        row.eachCell((cell, colNumber) => {
          const fieldName = headers[colNumber];
          if (fieldName && template.fieldsMap[fieldName]) {
            // 数据类型转换
            rowData[template.fieldsMap[fieldName]] = this.convertData(
              cell.value, 
              template.fieldTypes[template.fieldsMap[fieldName]]
            );
          }
        });
        
        results.push({
          data: rowData,
          rowNumber: rowNumber
        });
      });
      
      return results;
    }
  }
  
  // 批量导入异步处理器
  class BatchImportProcessor {
    constructor(taskQueue, dbService) {
      this.taskQueue = taskQueue;
      this.dbService = dbService;
    }
    
    async processBatchImport(data, template, taskId, userId) {
      // 添加到任务队列
      await this.taskQueue.add('batch_import', {
        data,
        template,
        taskId,
        userId
      }, {
        attempts: 3,
        removeOnComplete: true
      });
    }
    
    // 处理函数
    async handleImportTask(job) {
      const { data, template, taskId, userId } = job.data;
      
      try {
        // 开启事务
        await this.dbService.beginTransaction();
        
        // 批量处理数据，使用批次插入
        const batchSize = 500;
        let successCount = 0;
        let currentBatch = [];
        
        for (let i = 0; i < data.length; i++) {
          currentBatch.push(data[i].data);
          
          if (currentBatch.length >= batchSize || i === data.length - 1) {
            // 批量插入数据库
            const result = await this.dbService.batchInsert(
              template.tableName, 
              currentBatch,
              template.insertOptions
            );
            successCount += result.insertedCount;
            currentBatch = [];
            
            // 更新任务进度
            await this.updateImportProgress(
              taskId, 
              Math.round((i + 1) / data.length * 100),
              successCount
            );
          }
        }
        
        // 提交事务
        await this.dbService.commitTransaction();
        
        // 更新任务状态
        await this.updateImportTask(taskId, {
          status: 'completed',
          successCount,
          totalCount: data.length,
          completedAt: new Date()
        });
        
        return { success: true, successCount };
      } catch (error) {
        // 回滚事务
        await this.dbService.rollbackTransaction();
        
        // 更新任务失败状态
        await this.updateImportTask(taskId, {
          status: 'failed',
          errorMessage: error.message
        });
        
        throw error;
      }
    }
  }
  ```
- **性能优化**：
  - 流式处理大文件，避免内存溢出
  - 分批处理和插入数据
  - 使用连接池优化数据库连接
  - 异步任务队列，避免阻塞主线程
- **错误处理**：
  - 详细的错误日志记录
  - 错误信息可视化展示
  - 支持部分成功场景，提供错误数据下载
- **安全措施**：
  - 文件类型白名单验证
  - 上传文件大小限制
  - SQL注入防护
  - 导入权限严格控制

#### 4.9.2 数据导出功能
- **功能概述**：支持将系统内各类数据导出为Excel、CSV、PDF等格式，满足数据备份、报表生成和数据分析需求
- **支持的导出数据**：
  - 用户数据导出（员工信息、部门结构、权限配置）
  - 项目数据导出（项目列表、项目详情、项目文档）
  - 产品数据导出（产品目录、库存信息、规格参数）
  - 销售数据导出（订单信息、销售统计、客户信息）
  - 报表数据导出（项目进度报表、资源利用率报表）
  - 系统日志导出（操作日志、错误日志）
- **技术架构**：
  - 前端：导出配置界面，格式选择，列选择，分页导出
  - 后端：数据查询优化，流式数据处理，模板渲染
  - 生成：Excel生成（exceljs/xlsx），PDF生成（pdfmake/jspdf）
- **导出流程**：
  1. **导出配置**：用户选择导出数据类型、字段、格式和筛选条件
  2. **数据查询**：根据配置查询数据库
  3. **数据转换**：将数据转换为指定格式
  4. **文件生成**：创建文件并写入数据
  5. **文件下载**：提供文件下载链接
- **核心代码实现**：
  ```javascript
  // 数据导出服务
  class DataExportService {
    constructor(dataSource, exportFormatters, fileStorage) {
      this.dataSource = dataSource;
      this.exportFormatters = exportFormatters;
      this.fileStorage = fileStorage;
    }
    
    async exportData(exportConfig, userId) {
      try {
        // 1. 验证用户权限
        await this.validateExportPermission(exportConfig.dataType, userId);
        
        // 2. 创建导出任务
        const exportTask = await this.createExportTask(exportConfig, userId);
        
        // 3. 查询数据
        const data = await this.dataSource.queryData(
          exportConfig.dataType,
          exportConfig.filters,
          exportConfig.selectedFields,
          exportConfig.sort,
          exportConfig.limit
        );
        
        // 4. 获取对应的格式化器
        const formatter = this.exportFormatters[exportConfig.format];
        if (!formatter) {
          throw new Error(`不支持的导出格式: ${exportConfig.format}`);
        }
        
        // 5. 格式化数据
        const formattedData = await formatter.format(data, exportConfig);
        
        // 6. 生成文件
        const fileName = `${exportConfig.dataType}_${new Date().getTime()}.${formatter.getExtension()}`;
        const fileBuffer = await formatter.generateFile(formattedData);
        
        // 7. 保存文件
        const fileUrl = await this.fileStorage.storeTemporaryFile(
          fileName,
          fileBuffer,
          formatter.getMimeType()
        );
        
        // 8. 更新任务状态
        await this.updateExportTask(exportTask.id, {
          status: 'completed',
          fileUrl: fileUrl,
          recordCount: data.length,
          completedAt: new Date()
        });
        
        return {
          success: true,
          taskId: exportTask.id,
          fileUrl: fileUrl,
          recordCount: data.length
        };
      } catch (error) {
        console.error('Export error:', error);
        // 更新任务失败状态
        if (exportTask) {
          await this.updateExportTask(exportTask.id, {
            status: 'failed',
            errorMessage: error.message
          });
        }
        throw new ExportException('导出过程中发生错误', error);
      }
    }
    
    // 大数据量导出（分页流式处理）
    async exportLargeData(exportConfig, userId) {
      try {
        // 创建导出任务
        const exportTask = await this.createExportTask(exportConfig, userId, true);
        
        // 获取对应的格式化器
        const formatter = this.exportFormatters[exportConfig.format];
        
        // 初始化临时文件
        const tempFilePath = await this.initializeTempFile(formatter.getExtension());
        
        // 分页查询并流式写入
        const pageSize = 1000;
        let totalCount = 0;
        let currentPage = 1;
        let hasMoreData = true;
        
        while (hasMoreData) {
          // 查询一页数据
          const data = await this.dataSource.queryData(
            exportConfig.dataType,
            exportConfig.filters,
            exportConfig.selectedFields,
            exportConfig.sort,
            pageSize,
            (currentPage - 1) * pageSize
          );
          
          if (data.length === 0) {
            hasMoreData = false;
          } else {
            // 追加数据到文件
            await formatter.appendToFile(tempFilePath, data, exportConfig, currentPage === 1);
            
            totalCount += data.length;
            currentPage++;
            
            // 更新进度
            await this.updateExportProgress(
              exportTask.id,
              Math.round(totalCount / exportConfig.totalCount * 100),
              totalCount
            );
          }
        }
        
        // 完成文件处理
        await formatter.finalizeFile(tempFilePath);
        
        // 上传文件并获取URL
        const fileBuffer = await fs.promises.readFile(tempFilePath);
        const fileName = `${exportConfig.dataType}_${new Date().getTime()}.${formatter.getExtension()}`;
        const fileUrl = await this.fileStorage.storeTemporaryFile(
          fileName,
          fileBuffer,
          formatter.getMimeType()
        );
        
        // 清理临时文件
        await fs.promises.unlink(tempFilePath);
        
        // 更新任务状态
        await this.updateExportTask(exportTask.id, {
          status: 'completed',
          fileUrl: fileUrl,
          recordCount: totalCount,
          completedAt: new Date()
        });
        
        return {
          success: true,
          taskId: exportTask.id,
          fileUrl: fileUrl,
          recordCount: totalCount
        };
      } catch (error) {
        console.error('Large data export error:', error);
        // 清理资源并更新状态
        // ...
        throw error;
      }
    }
  }
  
  // Excel格式化器
  class ExcelFormatter {
    constructor() {}
    
    async format(data, config) {
      // 处理数据格式
      return data.map(row => {
        const formattedRow = {};
        
        // 应用字段映射和数据转换
        Object.keys(row).forEach(fieldName => {
          const fieldConfig = config.fieldConfig?.[fieldName];
          if (fieldConfig) {
            // 应用数据转换
            if (fieldConfig.transformer) {
              formattedRow[fieldConfig.label || fieldName] = fieldConfig.transformer(row[fieldName]);
            } else {
              formattedRow[fieldConfig.label || fieldName] = row[fieldName];
            }
          } else {
            formattedRow[fieldName] = row[fieldName];
          }
        });
        
        return formattedRow;
      });
    }
    
    async generateFile(formattedData) {
      const workbook = new ExcelJS.Workbook();
      const worksheet = workbook.addWorksheet('Data');
      
      if (formattedData.length > 0) {
        // 设置表头
        const headers = Object.keys(formattedData[0]);
        worksheet.addRow(headers);
        
        // 设置表头样式
        const headerRow = worksheet.getRow(1);
        headerRow.font = { bold: true };
        headerRow.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'DDDDDD' } };
        
        // 添加数据行
        formattedData.forEach(row => {
          worksheet.addRow(Object.values(row));
        });
        
        // 自动调整列宽
        worksheet.columns.forEach(column => {
          const maxLength = Math.max(...column.values.map(value => 
            value ? String(value).length : 0
          ));
          column.width = Math.min(maxLength + 2, 50); // 最大宽度限制为50
        });
      }
      
      // 生成Buffer
      const buffer = await workbook.xlsx.writeBuffer();
      return buffer;
    }
    
    getExtension() { return 'xlsx'; }
    getMimeType() { return 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'; }
  }
  ```
- **性能优化**：
  - 流式数据处理，避免大数据量内存溢出
  - 数据库查询优化，合理使用索引和分页
  - 异步任务处理长时间运行的导出操作
  - 临时文件存储，避免服务器内存压力
- **用户体验优化**：
  - 导出进度实时显示
  - 导出历史记录管理
  - 支持导出任务取消
  - 自动清理过期的临时导出文件
- **安全措施**：
  - 严格的导出权限控制
  - 敏感数据脱敏处理
  - 导出文件访问期限限制
  - 导出操作审计日志

#### 4.9.3 数据迁移工具
- **功能概述**：提供跨系统、跨版本的数据迁移能力，支持从旧系统平滑迁移到新系统，确保数据完整性和业务连续性
- **迁移类型支持**：
  - 系统升级数据迁移：版本升级时的结构和数据迁移
  - 异构系统迁移：从其他系统导入历史数据
  - 环境迁移：开发/测试/生产环境间的数据同步
  - 数据归档：将历史数据迁移到归档存储
- **迁移架构**：
  - 源数据适配器：支持多种数据源接入（MySQL, SQL Server, Oracle, CSV等）
  - 数据转换引擎：字段映射、数据清洗、格式转换
  - 目标数据写入器：支持多种目标系统写入
  - 迁移监控与回滚：实时监控迁移进度，支持失败回滚
- **核心功能模块**：
  - **数据源配置**：连接配置管理，支持多种数据库和文件格式
  - **数据映射设计器**：可视化字段映射配置，支持复杂转换规则
  - **迁移任务管理**：任务创建、调度、监控和管理
  - **数据验证工具**：迁移前后数据一致性验证
  - **增量迁移支持**：支持增量数据同步，减少业务影响
- **迁移流程**：
  1. **迁移前准备**：数据评估、迁移计划制定、备份
  2. **迁移配置**：数据源配置、目标配置、映射规则配置
  3. **预验证**：迁移规则验证、小规模测试
  4. **执行迁移**：数据提取、转换、加载
  5. **迁移后验证**：数据一致性检查、业务功能验证
  6. **切换与优化**：系统切换、性能优化
- **核心代码实现**：
  ```javascript
  // 数据迁移管理器
  class DataMigrationManager {
    constructor(sourceAdapterFactory, transformationEngine, targetWriterFactory, transactionManager, logger) {
      this.sourceAdapterFactory = sourceAdapterFactory;
      this.transformationEngine = transformationEngine;
      this.targetWriterFactory = targetWriterFactory;
      this.transactionManager = transactionManager;
      this.logger = logger;
    }
    
    async executeMigration(migrationConfig) {
      let sourceAdapter = null;
      let targetWriter = null;
      let migrationTask = null;
      
      try {
        // 1. 创建迁移任务记录
        migrationTask = await this.createMigrationTask(migrationConfig);
        
        // 2. 初始化源数据适配器
        sourceAdapter = await this.sourceAdapterFactory.createAdapter(
          migrationConfig.source.type,
          migrationConfig.source.config
        );
        
        // 3. 初始化目标数据写入器
        targetWriter = await this.targetWriterFactory.createWriter(
          migrationConfig.target.type,
          migrationConfig.target.config
        );
        
        // 4. 执行前置检查
        await this.performPreChecks(sourceAdapter, targetWriter, migrationConfig);
        
        // 5. 更新任务状态为执行中
        await this.updateMigrationTask(migrationTask.id, { 
          status: 'running',
          startTime: new Date()
        });
        
        // 6. 执行实际迁移
        const result = await this.performMigration(
          sourceAdapter,
          targetWriter,
          migrationConfig,
          migrationTask.id
        );
        
        // 7. 更新任务状态为完成
        await this.updateMigrationTask(migrationTask.id, {
          status: 'completed',
          endTime: new Date(),
          successCount: result.successCount,
          failedCount: result.failedCount,
          warnings: result.warnings
        });
        
        return {
          success: true,
          taskId: migrationTask.id,
          result: result
        };
      } catch (error) {
        // 8. 错误处理和回滚
        this.logger.error('Migration failed:', error);
        
        if (migrationTask) {
          await this.updateMigrationTask(migrationTask.id, {
            status: 'failed',
            endTime: new Date(),
            errorMessage: error.message
          });
        }
        
        // 如果配置了自动回滚，则执行回滚
        if (migrationConfig.rollbackOnError && targetWriter) {
          try {
            await this.performRollback(targetWriter, migrationConfig, migrationTask?.id);
          } catch (rollbackError) {
            this.logger.error('Rollback failed:', rollbackError);
          }
        }
        
        throw new MigrationException('数据迁移失败', error);
      } finally {
        // 9. 清理资源
        if (sourceAdapter) {
          await sourceAdapter.close();
        }
        if (targetWriter) {
          await targetWriter.close();
        }
      }
    }
    
    async performMigration(sourceAdapter, targetWriter, config, taskId) {
      // 计算总数用于进度跟踪
      const totalCount = await sourceAdapter.count(config.entity);
      const batchSize = config.batchSize || 1000;
      
      let processedCount = 0;
      let successCount = 0;
      let failedCount = 0;
      const warnings = [];
      
      // 分批处理
      while (processedCount < totalCount) {
        // 1. 读取一批数据
        const sourceData = await sourceAdapter.read(
          config.entity,
          batchSize,
          processedCount,
          config.filters
        );
        
        if (sourceData.length === 0) break;
        
        // 2. 开启事务
        const transaction = await this.transactionManager.beginTransaction();
        
        try {
          // 3. 数据转换
          const transformedData = await this.transformationEngine.transform(
            sourceData,
            config.mappingRules
          );
          
          // 4. 写入目标系统
          const writeResult = await targetWriter.writeBatch(
            config.target.entity,
            transformedData,
            transaction
          );
          
          // 5. 提交事务
          await this.transactionManager.commitTransaction(transaction);
          
          // 更新计数
          successCount += writeResult.successCount;
          failedCount += writeResult.failedCount;
          
          if (writeResult.warnings && writeResult.warnings.length > 0) {
            warnings.push(...writeResult.warnings);
          }
          
          // 6. 更新进度
          processedCount += sourceData.length;
          await this.updateMigrationProgress(
            taskId,
            Math.round(processedCount / totalCount * 100),
            successCount,
            failedCount
          );
          
        } catch (batchError) {
          // 回滚事务
          await this.transactionManager.rollbackTransaction(transaction);
          
          failedCount += sourceData.length;
          warnings.push(`批次处理失败: ${batchError.message}`);
          
          // 如果配置为继续执行，则继续处理下一批
          if (!config.continueOnError) {
            throw batchError;
          }
        }
      }
      
      return {
        successCount,
        failedCount,
        warnings
      };
    }
  }
  
  // 数据转换引擎
  class DataTransformationEngine {
    constructor(transformers) {
      this.transformers = transformers;
    }
    
    async transform(data, mappingRules) {
      const transformedData = [];
      
      for (const record of data) {
        const transformedRecord = {};
        let isValid = true;
        const recordWarnings = [];
        
        // 应用字段映射规则
        for (const [sourceField, rule] of Object.entries(mappingRules)) {
          try {
            // 获取源字段值
            let sourceValue = this.getValueByPath(record, sourceField);
            
            // 应用转换函数
            if (rule.transform) {
              const transformer = this.getTransformer(rule.transform);
              sourceValue = await transformer.transform(sourceValue, rule.options);
            }
            
            // 应用验证
            if (rule.validate) {
              const validationResult = await this.validateValue(sourceValue, rule.validate);
              if (!validationResult.isValid) {
                isValid = false;
                recordWarnings.push(`字段 '${sourceField}' 验证失败: ${validationResult.message}`);
              }
            }
            
            // 设置目标字段值
            this.setValueByPath(transformedRecord, rule.targetField, sourceValue);
          } catch (error) {
            isValid = false;
            recordWarnings.push(`字段 '${sourceField}' 转换失败: ${error.message}`);
          }
        }
        
        // 添加默认值
        for (const [field, defaultValue] of Object.entries(mappingRules.defaultValues || {})) {
          if (transformedRecord[field] === undefined) {
            transformedRecord[field] = typeof defaultValue === 'function' ? 
              defaultValue(record) : defaultValue;
          }
        }
        
        transformedData.push({
          data: transformedRecord,
          isValid,
          warnings: recordWarnings
        });
      }
      
      return transformedData;
    }
    
    getTransformer(transformerName) {
      const transformer = this.transformers[transformerName];
      if (!transformer) {
        throw new Error(`未知的转换器: ${transformerName}`);
      }
      return transformer;
    }
    
    // 根据路径获取对象属性值
    getValueByPath(obj, path) {
      const keys = path.split('.');
      let value = obj;
      
      for (const key of keys) {
        if (value === undefined || value === null) {
          return undefined;
        }
        value = value[key];
      }
      
      return value;
    }
    
    // 根据路径设置对象属性值
    setValueByPath(obj, path, value) {
      const keys = path.split('.');
      const lastKey = keys.pop();
      
      let current = obj;
      for (const key of keys) {
        if (!current[key]) {
          current[key] = {};
        }
        current = current[key];
      }
      
      current[lastKey] = value;
    }
    
    async validateValue(value, validationRules) {
      for (const [ruleName, ruleOptions] of Object.entries(validationRules)) {
        let isValid = true;
        let message = '';
        
        switch (ruleName) {
          case 'required':
            isValid = value !== undefined && value !== null && value !== '';
            message = '此字段为必填项';
            break;
          case 'minLength':
            isValid = String(value).length >= ruleOptions;
            message = `最小长度为 ${ruleOptions}`;
            break;
          case 'maxLength':
            isValid = String(value).length <= ruleOptions;
            message = `最大长度为 ${ruleOptions}`;
            break;
          case 'pattern':
            isValid = ruleOptions.test(String(value));
            message = '格式不正确';
            break;
          case 'custom':
            const customResult = await ruleOptions(value);
            isValid = customResult.isValid;
            message = customResult.message || '自定义验证失败';
            break;
        }
        
        if (!isValid) {
          return { isValid: false, message };
        }
      }
      
      return { isValid: true };
    }
  }
  ```
- **迁移策略**：
  - 全量迁移：一次性迁移所有历史数据
  - 增量迁移：基于时间戳或变更日志进行增量同步
  - 并行迁移：部分模块先迁移，其他模块后续迁移
  - 混合迁移：结合全量和增量的混合策略
- **数据验证机制**：
  - 记录数比对：迁移前后记录数量一致性检查
  - 数据抽样验证：关键数据抽样核对
  - 业务规则验证：应用业务规则进行一致性检查
  - 校验和验证：使用MD5/SHA等算法进行数据完整性验证
- **性能优化**：
  - 批量处理：减少数据库交互次数
  - 并行处理：多线程/多进程并行迁移
  - 索引优化：迁移过程中临时禁用索引，迁移后重建
  - 资源限制：控制迁移过程的系统资源占用
- **安全措施**：
  - 敏感数据加密传输
  - 迁移账号权限最小化
  - 迁移过程审计日志
  - 数据脱敏处理（如需要）

### 4.10 通知系统设计

#### 4.10.1 统一通知中心
- **通知中心架构**：
  ```javascript
  // 通知发送器接口
  class NotificationSender {
    async send(notification, recipient) {}
  }
  
  // 站内信实现
  class InternalMessageSender extends NotificationSender {}
  
  // 邮件发送实现
  class EmailSender extends NotificationSender {}
  
  // 短信发送实现
  class SMSSender extends NotificationSender {}
  
  // 通知服务
  class NotificationService {
    constructor(senders) {
      this.senders = senders;
    }
    
    async sendNotification(type, recipients, content, options = {}) {
      const notification = {
        type,
        content,
        timestamp: new Date(),
        ...options
      };
      
      // 根据通知类型和用户偏好选择发送渠道
      for (const recipient of recipients) {
        const preferredChannels = await this.getUserPreferences(recipient);
        for (const channel of preferredChannels) {
          await this.senders[channel].send(notification, recipient);
        }
      }
    }
  }
  ```
- **智能通知规则**：
  - 基于用户角色和偏好的通知推送
  - 通知优先级和聚合发送
  - 通知阅读状态跟踪

#### 4.10.2 事件驱动通知
- **使用消息队列**：RabbitMQ/Kafka
- **异步处理**：非阻塞通知发送
- **重试机制**：确保通知送达

### 4.11 审批工作流设计

#### 4.11.1 工作流引擎
- **功能概述**：提供灵活可配置的工作流引擎，支持各种业务流程的自动化流转，如项目审批、资源申请、文档审核等
- **核心特性**：
  - 可视化工作流设计器
  - 灵活的条件分支和并行流程
  - 任务分配和通知机制
  - 流程实例监控和管理
  - 支持动态修改流程定义
- **架构设计**：
  - **流程定义层**：存储流程模板、节点、转换条件等
  - **流程实例层**：管理运行中的流程实例状态
  - **任务执行层**：处理任务分配、执行和状态更新
  - **事件机制层**：处理流程中的各种事件和触发条件
- **关键组件**：
  - **流程定义管理器**：负责工作流模板的CRUD操作
  - **流程引擎核心**：处理流程实例的创建、执行和终止
  - **任务管理器**：管理用户任务的分配和状态更新
  - **表达式引擎**：支持条件表达式和动态规则
  - **事件监听器**：响应流程各阶段的事件
- **流程定义数据模型**：
  ```javascript
  // 流程定义示例
  {
    id: "project_approval",
    name: "项目审批流程",
    description: "嵌入式项目立项审批流程",
    version: 1,
    startNode: "start_event",
    nodes: [
      {
        id: "start_event",
        type: "start_event",
        name: "开始",
        outgoing: ["to_project_manager"]
      },
      {
        id: "project_manager_approval",
        type: "user_task",
        name: "项目经理审批",
        assigneeRule: "${project.managerId}",
        candidateGroups: ["project_managers"],
        outgoing: ["to_director_approval", "reject_path"]
      },
      // 其他节点简化显示
    ],
    variables: [
      { name: "project", type: "object" },
      { name: "approved", type: "boolean" },
      { name: "comment", type: "string" }
    ]
  }
  ```
- **WorkflowEngine核心功能**：
  - 流程实例的创建、执行和终止
  - 任务分配与状态管理
  - 条件判断与流程分支控制
  - 流程变量管理
  - 事件触发与处理
  - 流程监控与历史记录
- **流程节点类型**：
  - 开始事件(Start Event)
  - 结束事件(End Event)
  - 用户任务(User Task)
  - 服务任务(Service Task)
  - 网关(Gateway)
  - 序列流(Sequence Flow)
- **任务分配策略**：
  - 固定分配(Assignee)
  - 候选人组(Candidate Groups)
  - 动态表达式分配
  - 任务池分配
    }
    
    // 执行流程
    async execute(processInstance) {
      const processDefinition = await this.processDefinitionRepository.getById(
        processInstance.processDefinitionId
      );
      
      let shouldContinue = true;
      
      while (shouldContinue) {
        const currentNodeIds = [...processInstance.currentNodes];
        const newCurrentNodes = [];
        
        for (const nodeId of currentNodeIds) {
          const node = processDefinition.nodes.find(n => n.id === nodeId);
          if (!node) continue;
          
          // 根据节点类型执行不同的操作
          switch (node.type) {
            case 'start_event':
              // 处理开始事件
              const startOutgoing = node.outgoing || [];
              for (const flowId of startOutgoing) {
                const flow = processDefinition.nodes.find(n => n.id === flowId);
                if (flow && this.evaluateCondition(flow.condition, processInstance.variables)) {
                  newCurrentNodes.push(flow.target);
                }
              }
              break;
              
            case 'user_task':
              // 创建用户任务
              await this.taskManager.createTask({
                processInstanceId: processInstance.id,
                taskDefinitionKey: node.id,
                name: node.name,
                assignee: this.resolveAssignee(node.assigneeRule, processInstance.variables),
                candidateGroups: node.candidateGroups || [],
                formKey: node.formKey,
                variables: processInstance.variables
              });
              break;
              
            case 'service_task':
              // 执行服务任务
              await this.executeServiceTask(node, processInstance);
              const serviceOutgoing = node.outgoing || [];
              for (const flowId of serviceOutgoing) {
                const flow = processDefinition.nodes.find(n => n.id === flowId);
                if (flow && this.evaluateCondition(flow.condition, processInstance.variables)) {
                  newCurrentNodes.push(flow.target);
                }
              }
              break;
              
            case 'end_event':
              // 处理结束事件
              processInstance.status = 'completed';
              processInstance.endTime = new Date();
              await this.eventBus.publish('process.completed', processInstance);
              shouldContinue = false;
              break;
          }
        }
        
        // 更新当前节点
        processInstance.currentNodes = newCurrentNodes.filter(nodeId => 
          processDefinition.nodes.some(n => n.id === nodeId)
        );
        
        // 保存流程实例状态
        await this.processInstanceRepository.update(processInstance);
        
        // 如果没有更多节点或有用户任务需要等待，则停止执行
        if (processInstance.currentNodes.length === 0 || 
            processInstance.currentNodes.some(nodeId => {
              const node = processDefinition.nodes.find(n => n.id === nodeId);
              return node && node.type === 'user_task';
            })) {
          shouldContinue = false;
        }
      }
    }
    
    // 提交任务
    async completeTask(taskId, variables = {}) {
      // 获取任务
      const task = await this.taskManager.getTask(taskId);
      if (!task) {
        throw new Error(`任务不存在: ${taskId}`);
      }
      
      // 更新任务状态
      await this.taskManager.completeTask(taskId, variables);
      
      // 获取流程实例
      const processInstance = await this.processInstanceRepository.getById(task.processInstanceId);
      if (!processInstance) {
        throw new Error(`流程实例不存在: ${task.processInstanceId}`);
      }
      
      // 更新流程变量
      processInstance.variables = { ...processInstance.variables, ...variables };
      
      // 触发任务完成事件
      await this.eventBus.publish('task.completed', { task, processInstance });
      
      // 继续执行流程
      await this.execute(processInstance);
      
      return processInstance;
    }
    
    // 评估条件表达式
    evaluateCondition(condition, variables) {
      if (!condition || condition === 'true') return true;
      if (condition === 'false') return false;
      
      // 这里可以集成表达式引擎，如JavaScript表达式、EL表达式等
      try {
        // 简单的表达式评估示例
        // 实际项目中应使用更安全的表达式引擎
        const sandbox = { ...variables };
        return new Function('return ' + condition).call(sandbox);
      } catch (error) {
        console.error('Condition evaluation error:', error);
        return false;
      }
    }
    
    // 解析任务分配规则
    resolveAssignee(assigneeRule, variables) {
      if (!assigneeRule) return null;
      
      // 处理表达式形式的分配规则
      if (assigneeRule.startsWith('${') && assigneeRule.endsWith('}')) {
        const expression = assigneeRule.substring(2, assigneeRule.length - 1);
        try {
          const sandbox = { ...variables };
          return new Function('return ' + expression).call(sandbox);
        } catch (error) {
          console.error('Assignee resolution error:', error);
          return null;
        }
      }
      
      return assigneeRule;
    }
    
    // 执行服务任务
    async executeServiceTask(node, processInstance) {
      try {
        // 根据服务任务配置执行相应的服务
        const serviceImplementation = node.implementation || node.serviceTaskClass;
        if (serviceImplementation) {
          // 这里可以通过反射或服务注册表获取服务实例
          const service = this.getService(serviceImplementation);
          if (service && typeof service.execute === 'function') {
            const result = await service.execute(processInstance.variables, node.configuration);
            // 更新流程变量
            if (result) {
              processInstance.variables = { ...processInstance.variables, ...result };
            }
          }
        }
      } catch (error) {
        console.error('Service task execution error:', error);
        // 处理服务任务执行错误
        if (node.errorHandling === 'terminate') {
          processInstance.status = 'terminated';
          processInstance.endTime = new Date();
          await this.eventBus.publish('process.terminated', { processInstance, error });
        } else if (node.errorHandling === 'retry' && node.maxRetries > 0) {
          // 实现重试逻辑
        }
      }
    }
  }
  ```
- **性能优化**：
  - 流程实例状态缓存机制
  - 异步任务执行队列
  - 定期清理已完成流程实例
  - 数据库索引优化
- **扩展点**：
  - 自定义任务分配策略
  - 自定义表单解析器
  - 自定义条件表达式引擎
  - 自定义事件监听器
- **监控与管理**：
  - 流程实例状态监控面板
  - 任务执行统计
  - 流程性能分析
  - 异常流程处理机制

#### 4.11.2 审批类型支持
- **功能概述**：提供多种审批类型，满足嵌入式项目管理中不同场景的审批需求
- **支持的审批类型**：
  - **项目立项审批**：控制新项目的启动，确保资源合理分配和项目可行性评估
  - **需求变更审批**：管理项目执行过程中的需求变更，控制项目范围蔓延
  - **资源申请审批**：管理硬件设备、开发环境等资源的申请和分配
  - **技术方案审批**：对关键技术方案进行评审，确保技术选型合理
  - **文档审核**：对重要技术文档、项目文档进行审核和发布
  - **请假审批**：管理团队成员的请假和出差申请
  - **采购审批**：控制项目采购流程，确保预算合理使用
  - **验收审批**：管理项目阶段性验收和最终验收流程
- **审批流程配置**：
  - **单级审批**：简单场景下的一级审批流程
  - **多级审批**：复杂场景下的多级串行审批
  - **并行审批**：需要多方同时审批的场景
  - **会签审批**：需要所有参与方一致同意的场景
  - **或签审批**：只要一方同意即可通过的场景
- **审批条件配置**：
  - **金额阈值条件**：根据申请金额自动选择不同审批流程
  - **项目类型条件**：根据项目类型选择相应审批模板
  - **紧急程度条件**：根据紧急程度调整审批流程
  - **自定义表达式**：支持复杂业务规则的条件表达式
- **审批流程示例**：
  ```javascript
  // 项目立项审批流程定义示例（简化版）
  const projectApprovalProcess = {
    id: "project_initiation_approval",
    name: "项目立项审批",
    version: 1,
    
    // 条件路由配置
    conditionalRoutings: [
      { id: "budget_routing", condition: "project.budget > 100000", processPath: "high_budget_approval" },
      { id: "default_routing", condition: "true", processPath: "standard_approval" }
    ],
    
    // 审批流程路径
    processPaths: {
      standard_approval: {
        steps: [
          { id: "dept_manager_approval", name: "部门经理审批", assigneeRule: "${project.department.managerId}" },
          { id: "project_director_approval", name: "项目总监审批", assigneeRule: "${system.projectDirectorId}" }
        ]
      },
      
      high_budget_approval: {
        steps: [
          { id: "dept_manager_approval", name: "部门经理审批" },
          { id: "project_director_approval", name: "项目总监审批" },
          { id: "financial_review", name: "财务审核" },
          { id: "ceo_approval", name: "CEO审批" }
        ]
      }
    },
    
    // 表单配置（简化）
    formConfiguration: {
      requiredFields: ["projectName", "budget", "timeline", "objectives"]
    }
  };
  ```
- **审批流程配置组件**：
  - 审批模板管理
  - 流程步骤配置
  - 条件规则设置
  - 审批权限配置
  - 表单字段配置
  - 通知规则设置
        channels: ["system", "email", "sms"],
        template: "approval_rejected"
      },
      timeout: {
        recipients: ["currentApprover", "manager"],
        channels: ["system", "email", "sms"],
        reminderIntervals: ["PT24H", "PT48H"]
      }
    },
    
    // 审批结果处理配置
    resultHandlers: {
      approved: {
        actions: [
          { type: "createProject", parameters: { status: "approved" } },
          { type: "allocateResources", parameters: { basedOn: "project.requirements" } },
          { type: "notifyTeam", parameters: { template: "project_initiated" } }
        ]
      },
      rejected: {
        actions: [
          { type: "notifyInitiator", parameters: { includeFeedback: true } },
          { type: "archiveRequest", parameters: { reason: "rejected" } }
        ]
      }
    }
  };
  ```
- **审批规则引擎**：
  - 基于表达式的规则配置
  - 动态审批人计算
  - 条件分支和流程跳转
  - 审批超时和自动处理
- **审批策略实现**：
  ```javascript
  // 审批策略工厂
  class ApprovalStrategyFactory {
    static createStrategy(type, options = {}) {
      switch (type) {
        case 'single':
          return new SingleApprovalStrategy(options);
        case 'multiple':
          return new MultipleApprovalStrategy(options);
        case 'parallel':
          return new ParallelApprovalStrategy(options);
        case 'joint':
          return new JointApprovalStrategy(options);
        case 'or':
          return new OrApprovalStrategy(options);
        default:
          throw new Error(`未知的审批策略类型: ${type}`);
      }
    }
  }
  
  // 基础审批策略
  class BaseApprovalStrategy {
    constructor(options = {}) {
      this.options = options;
    }
    
    // 检查是否可以继续审批流程
    async canProceed(approvalContext) {
      throw new Error('方法未实现');
    }
    
    // 获取下一步审批人
    async getNextApprovers(approvalContext) {
      throw new Error('方法未实现');
    }
  }
  
  // 单级审批策略
  class SingleApprovalStrategy extends BaseApprovalStrategy {
    async canProceed(approvalContext) {
      const { currentStep, approvalResults } = approvalContext;
      const currentStepResults = approvalResults.filter(r => r.stepId === currentStep.id);
      
      // 只要有一个审批结果即可
      return currentStepResults.length > 0;
    }
    
    async getNextApprovers(approvalContext) {
      const { currentStep, variables } = approvalContext;
      
      // 解析审批人规则
      const assignee = this.resolveAssignee(currentStep.assigneeRule, variables);
      return assignee ? [assignee] : [];
    }
    
    resolveAssignee(assigneeRule, variables) {
      // 实现审批人解析逻辑
      // 类似于工作流引擎中的实现
      return assigneeRule;
    }
  }
  
  // 并行审批策略
  class ParallelApprovalStrategy extends BaseApprovalStrategy {
    async canProceed(approvalContext) {
      const { currentStep, approvalResults } = approvalContext;
      const currentStepResults = approvalResults.filter(r => r.stepId === currentStep.id);
      const requiredApproversCount = currentStep.approvers?.length || 0;
      
      // 所有审批人都完成审批
      return currentStepResults.length === requiredApproversCount;
    }
    
    async getNextApprovers(approvalContext) {
      const { currentStep } = approvalContext;
      return currentStep.approvers || [];
    }
  }
  
  // 会签审批策略
  class JointApprovalStrategy extends BaseApprovalStrategy {
    async canProceed(approvalContext) {
      const { currentStep, approvalResults } = approvalContext;
      const currentStepResults = approvalResults.filter(r => r.stepId === currentStep.id);
      
      // 所有审批结果必须都是同意
      return currentStepResults.length > 0 && 
             currentStepResults.every(r => r.result === 'approved');
    }
    
    async getNextApprovers(approvalContext) {
      const { currentStep } = approvalContext;
      return currentStep.approvers || [];
    }
  }
  
  // 或签审批策略
  class OrApprovalStrategy extends BaseApprovalStrategy {
    async canProceed(approvalContext) {
      const { currentStep, approvalResults } = approvalContext;
      const currentStepResults = approvalResults.filter(r => r.stepId === currentStep.id);
      
      // 只要有一个审批人同意即可
      return currentStepResults.some(r => r.result === 'approved');
    }
    
    async getNextApprovers(approvalContext) {
      const { currentStep } = approvalContext;
      return currentStep.approvers || [];
    }
  }
  ```
- **审批数据模型**：
  - 审批实例(ApprovalInstance)
  - 审批步骤(ApprovalStep)
  - 审批结果(ApprovalResult)
  - 审批历史(ApprovalHistory)
- **审批报表与分析**：
  - 审批效率统计
  - 审批通过率分析
  - 部门审批负载分析
  - 审批超时率监控

#### 4.11.3 审批操作功能
- **功能概述**：提供完整的审批生命周期操作功能，支持用户发起、处理、查看和管理审批流程
- **核心操作功能**：
  - **发起审批**：创建新的审批申请，填写相关表单信息
  - **审批处理**：审批人进行同意、拒绝、转交等操作
  - **审批查询**：查看待办、已办、发起的审批列表
  - **审批详情**：查看审批完整流程和历史记录
  - **催办提醒**：对逾期未处理的审批进行催办
  - **撤销申请**：发起人在特定条件下撤销审批
  - **审批转交**：审批人将审批任务转交给其他人员
  - **条件审批**：根据业务条件自动决定审批结果
- **前端界面组件**：
  - 审批发起表单组件
  - 待办审批列表组件
  - 审批详情流程图组件
  - 审批历史时间线组件
  - 审批处理意见输入组件
  - 审批统计图表组件
- **主要API功能**：
  - 审批发起API
  - 审批列表查询API（待办、已办、发起）
  - 审批详情查询API
  - 审批处理API（同意、拒绝、转交）
  - 审批管理API（催办、撤销）
  - 审批附件管理API
  - 审批统计API
- **审批处理核心流程**：
  - 审批实例获取与权限验证
  - 审批操作记录与状态更新
  - 工作流引擎任务处理
  - 审批结果通知分发
  - 审批历史记录保存
  - 审计日志记录
        }
      );
      
      // 更新审批实例
      approval.status = workflowResult.status;
      
      // 更新当前步骤
      if (workflowResult.currentNodes && workflowResult.currentNodes.length > 0) {
        const nextTask = await this.getNextTask(workflowResult);
        approval.currentStep = this.createApprovalStep(nextTask, approval);
        approval.steps.push(approval.currentStep);
      } else if (workflowResult.status === 'completed') {
        // 流程已完成
        approval.currentStep = null;
        approval.completedAt = new Date();
        
        // 执行审批完成后的操作
        await this.executePostApprovalActions(approval);
      }
      
      // 保存审批实例
      await this.approvalRepository.update(approval);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'APPROVAL_APPROVED',
        userId,
        resourceId: approvalId,
        resourceType: 'approval',
        details: {
          approvalType: approval.processKey,
          processInstanceId: approval.processInstanceId
        }
      });
      
      // 发送通知
      await this.sendApprovalNotifications(approval, 'approved', userId);
      
      return approval;
    }
    
    // 处理审批拒绝
    async handleRejection(approvalId, userId, comment, rejectionReason) {
      // 类似handleApproval的实现
      // ...
    }
    
    // 处理审批转交
    async handleDelegation(approvalId, userId, delegateToUserId, reason) {
      // 获取审批实例
      const approval = await this.approvalRepository.findById(approvalId);
      if (!approval) {
        throw new Error('审批不存在');
      }
      
      // 验证权限
      if (!this.hasApprovalPermission(approval, userId)) {
        throw new Error('无权限转交此审批');
      }
      
      // 获取转交目标用户信息
      const delegateUser = await this.userService.findById(delegateToUserId);
      if (!delegateUser) {
        throw new Error('转交目标用户不存在');
      }
      
      // 执行转交操作
      await this.workflowEngine.delegateTask(approval.currentStep.taskId, delegateToUserId);
      
      // 记录转交操作
      const delegationAction = {
        id: `delegate_${Date.now()}`,
        approvalId,
        fromUserId: userId,
        toUserId: delegateToUserId,
        reason,
        timestamp: new Date()
      };
      
      approval.currentStep.delegations.push(delegationAction);
      approval.currentStep.assignee = delegateToUserId;
      
      // 保存更新
      await this.approvalRepository.update(approval);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'APPROVAL_DELEGATED',
        userId,
        resourceId: approvalId,
        resourceType: 'approval',
        details: {
          delegateTo: delegateToUserId,
          reason
        }
      });
      
      // 发送通知
      await this.notificationService.send({
        type: 'APPROVAL_DELEGATED_TO_YOU',
        recipients: [delegateToUserId],
        data: {
          approvalId,
          approvalTitle: approval.title,
          delegatedBy: userId,
          reason
        }
      });
      
      await this.notificationService.send({
        type: 'APPROVAL_DELEGATED',
        recipients: [userId],
        data: {
          approvalId,
          approvalTitle: approval.title,
          delegatedTo: delegateToUserId
        }
      });
      
      return approval;
    }
    
    // 验证审批权限
    hasApprovalPermission(approval, userId) {
      const currentStep = approval.currentStep;
      if (!currentStep) return false;
      
      // 检查是否是当前审批人
      if (currentStep.assignee === userId) return true;
      
      // 检查是否在候选审批人列表中
      if (currentStep.candidateUsers && currentStep.candidateUsers.includes(userId)) return true;
      
      // 检查用户角色组权限
      return this.hasGroupPermission(approval, userId);
    }
    
    // 发送审批通知
    async sendApprovalNotifications(approval, action, userId) {
      // 根据不同的审批操作发送不同的通知
      switch (action) {
        case 'approved':
          // 发送审批通过通知给发起人
          await this.notificationService.send({
            type: 'APPROVAL_PROGRESSED',
            recipients: [approval.initiatorId],
            data: {
              approvalId: approval.id,
              approvalTitle: approval.title,
              action: 'approved',
              approvedBy: userId
            }
          });
          
          // 如果有下一步审批人，发送待办通知
          if (approval.currentStep && approval.currentStep.assignee) {
            await this.notificationService.send({
              type: 'APPROVAL_ASSIGNED',
              recipients: [approval.currentStep.assignee],
              data: {
                approvalId: approval.id,
                approvalTitle: approval.title
              }
            });
          }
          break;
          
        case 'rejected':
          // 发送拒绝通知
          // ...
          break;
      }
    }
    
    // 执行审批完成后的操作
    async executePostApprovalActions(approval) {
      // 根据审批类型和配置执行相应的后处理操作
      const processConfig = await this.getProcessConfig(approval.processKey);
      if (processConfig && processConfig.resultHandlers) {
        const handler = processConfig.resultHandlers.approved;
        if (handler && handler.actions) {
          for (const action of handler.actions) {
            await this.executeAction(action, approval);
          }
        }
      }
    }
  }
  ```
- **审批操作安全性**：
  - 严格的权限控制机制
  - 审批操作审计日志
  - 敏感操作二次确认
  - 数据传输加密
- **用户体验优化**：
  - 审批表单智能预填
  - 批量审批功能
  - 审批快捷回复模板
  - 移动端审批适配
  - 审批进度实时推送
- **审批数据导出**：
  - 支持导出审批历史记录
  - 审批统计报表导出
  - 自定义导出字段

### 4.15 硬件资源管理设计

#### 4.15.1 硬件设备管理
- **功能概述**：提供全面的硬件设备生命周期管理，包括设备入库、分配、跟踪、维护和报废等功能
- **核心特性**：
  - 设备全生命周期管理
  - 设备实时状态监控
  - 设备使用情况追踪
  - 维护计划管理
  - 设备依赖关系管理
  - 盘点和审计功能
- **设备分类体系**：
  - **开发设备**：开发板、仿真器、调试器
  - **测试设备**：测试仪器、信号发生器、示波器
  - **生产设备**：编程器、烧录器、测试治具
  - **网络设备**：路由器、交换机、网关
  - **办公设备**：电脑、显示器、打印机
- **数据模型设计**：
  ```javascript
  // 硬件设备模型
  const deviceSchema = {
    id: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    model: { type: String, required: true },
    manufacturer: { type: String },
    serialNumber: { type: String, unique: true },
    deviceType: { type: String, required: true }, // 设备类别
    category: { type: String }, // 设备分类
    status: { 
      type: String, 
      enum: ['available', 'in_use', 'maintenance', 'damaged', 'retired'],
      default: 'available'
    },
    location: { type: String },
    currentUser: { type: String }, // 当前使用者ID
    currentProject: { type: String }, // 当前关联项目
    // 其他基础属性简化显示
  };
  ```
- **HardwareDeviceService核心功能**：
  - 硬件设备的创建、查询、更新和删除
  - 设备分配与归还管理
  - 设备状态跟踪与监控
  - 维护计划与历史记录管理
  - 设备依赖关系管理
  - 盘点和审计功能
  - 设备成本与折旧管理
- **设备生命周期管理**：
  - 设备入库与初始化
  - 设备使用与分配
  - 设备维护与修理
  - 设备升级与改造
  - 设备报废与处置
- **盘点与审计**：
  - 定期盘点功能
  - 设备使用审计
  - 异常使用检测
  - 合规性检查
        action: 'DEVICE_CREATED',
        userId: createdBy,
        resourceId: device.id,
        resourceType: 'device',
        details: { deviceName: device.name, deviceType: device.deviceType }
      });
      
      return device;
    }
    
    // 获取设备列表
    async getDevices(filters = {}, pagination = {}) {
      // 构建查询条件
      const query = {};
      
      if (filters.name) {
        query.name = { $regex: filters.name, $options: 'i' };
      }
      
      if (filters.model) {
        query.model = { $regex: filters.model, $options: 'i' };
      }
      
      if (filters.deviceType) {
        query.deviceType = filters.deviceType;
      }
      
      if (filters.status) {
        query.status = filters.status;
      }
      
      if (filters.location) {
        query.location = filters.location;
      }
      
      if (filters.currentUser) {
        query.currentUser = filters.currentUser;
      }
      
      if (filters.availableOnly) {
        query.status = 'available';
      }
      
      // 执行查询
      const devices = await this.deviceRepository.find(query, pagination);
      const totalCount = await this.deviceRepository.count(query);
      
      return {
        devices,
        totalCount,
        page: pagination.page || 1,
        pageSize: pagination.pageSize || 20
      };
    }
    
    // 获取设备详情
    async getDeviceById(deviceId) {
      const device = await this.deviceRepository.findById(deviceId);
      if (!device) {
        throw new Error('设备不存在');
      }
      
      // 加载关联信息
      if (device.currentUser) {
        device.userInfo = await this.userService.findById(device.currentUser);
      }
      
      if (device.currentProject) {
        device.projectInfo = await this.projectService.findById(device.currentProject);
      }
      
      return device;
    }
    
    // 更新设备信息
    async updateDevice(deviceId, updateData, updatedBy) {
      const device = await this.deviceRepository.findById(deviceId);
      if (!device) {
        throw new Error('设备不存在');
      }
      
      // 更新设备信息
      updateData.updatedAt = new Date();
      const updatedDevice = await this.deviceRepository.update(deviceId, updateData);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'DEVICE_UPDATED',
        userId: updatedBy,
        resourceId: deviceId,
        resourceType: 'device',
        details: { updatedFields: Object.keys(updateData) }
      });
      
      return updatedDevice;
    }
    
    // 分配设备给用户
    async assignDeviceToUser(deviceId, userId, projectId = null, startDate = new Date(), endDate = null, assignedBy) {
      // 验证设备存在
      const device = await this.deviceRepository.findById(deviceId);
      if (!device) {
        throw new Error('设备不存在');
      }
      
      // 验证设备状态
      if (device.status !== 'available') {
        throw new Error(`设备当前状态为${device.status}，无法分配`);
      }
      
      // 验证用户存在
      const user = await this.userService.findById(userId);
      if (!user) {
        throw new Error('用户不存在');
      }
      
      // 如果指定了项目，验证项目存在
      if (projectId) {
        const project = await this.projectService.findById(projectId);
        if (!project) {
          throw new Error('项目不存在');
        }
      }
      
      // 更新设备状态和分配信息
      const updateData = {
        status: 'in_use',
        currentUser: userId,
        currentProject: projectId,
        updatedAt: new Date()
      };
      
      // 更新分配历史
      if (!device.assignedUsers) {
        device.assignedUsers = [];
      }
      
      device.assignedUsers.push({
        userId,
        projectId,
        startDate,
        endDate,
        assignedBy
      });
      
      updateData.assignedUsers = device.assignedUsers;
      
      const updatedDevice = await this.deviceRepository.update(deviceId, updateData);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'DEVICE_ASSIGNED',
        userId: assignedBy,
        resourceId: deviceId,
        resourceType: 'device',
        details: {
          assignedTo: userId,
          projectId,
          startDate,
          endDate
        }
      });
      
      // 发送通知给被分配用户
      await this.notificationService.send({
        type: 'DEVICE_ASSIGNED_TO_YOU',
        recipients: [userId],
        data: {
          deviceId: device.id,
          deviceName: device.name,
          deviceModel: device.model,
          assignedBy
        }
      });
      
      return updatedDevice;
    }
    
    // 归还设备
    async returnDevice(deviceId, returnReason = '', returnedBy) {
      // 验证设备存在
      const device = await this.deviceRepository.findById(deviceId);
      if (!device) {
        throw new Error('设备不存在');
      }
      
      // 验证设备状态
      if (device.status !== 'in_use') {
        throw new Error(`设备当前状态为${device.status}，不是使用中状态`);
      }
      
      const currentUser = device.currentUser;
      
      // 更新设备状态
      const updateData = {
        status: 'available',
        currentUser: null,
        currentProject: null,
        updatedAt: new Date()
      };
      
      // 更新最近一次分配的结束日期
      if (device.assignedUsers && device.assignedUsers.length > 0) {
        const lastAssignment = device.assignedUsers[device.assignedUsers.length - 1];
        if (!lastAssignment.endDate) {
          lastAssignment.endDate = new Date();
          lastAssignment.returnReason = returnReason;
          updateData.assignedUsers = device.assignedUsers;
        }
      }
      
      const updatedDevice = await this.deviceRepository.update(deviceId, updateData);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'DEVICE_RETURNED',
        userId: returnedBy,
        resourceId: deviceId,
        resourceType: 'device',
        details: {
          returnedBy,
          returnReason
        }
      });
      
      return updatedDevice;
    }
    
    // 设备送修
    async sendDeviceForMaintenance(deviceId, maintenanceReason, sentBy) {
      // 验证设备存在
      const device = await this.deviceRepository.findById(deviceId);
      if (!device) {
        throw new Error('设备不存在');
      }
      
      // 更新设备状态
      const updateData = {
        status: 'maintenance',
        updatedAt: new Date()
      };
      
      // 记录维护历史
      if (!device.maintenanceHistory) {
        device.maintenanceHistory = [];
      }
      
      device.maintenanceHistory.push({
        date: new Date(),
        performedBy: sentBy,
        description: maintenanceReason,
        status: 'pending'
      });
      
      updateData.maintenanceHistory = device.maintenanceHistory;
      
      const updatedDevice = await this.deviceRepository.update(deviceId, updateData);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'DEVICE_SENT_FOR_MAINTENANCE',
        userId: sentBy,
        resourceId: deviceId,
        resourceType: 'device',
        details: { maintenanceReason }
      });
      
      return updatedDevice;
    }
    
    // 设备维护完成
    async completeDeviceMaintenance(deviceId, maintenanceDetails, cost, completedBy) {
      // 验证设备存在
      const device = await this.deviceRepository.findById(deviceId);
      if (!device) {
        throw new Error('设备不存在');
      }
      
      // 验证设备状态
      if (device.status !== 'maintenance') {
        throw new Error(`设备当前状态为${device.status}，不是维修中状态`);
      }
      
      // 更新设备状态和维护历史
      const updateData = {
        status: 'available',
        updatedAt: new Date()
      };
      
      // 更新最近一次维护记录
      if (device.maintenanceHistory && device.maintenanceHistory.length > 0) {
        const lastMaintenance = device.maintenanceHistory[device.maintenanceHistory.length - 1];
        if (lastMaintenance.status === 'pending') {
          lastMaintenance.completedDate = new Date();
          lastMaintenance.status = 'completed';
          lastMaintenance.details = maintenanceDetails;
          lastMaintenance.cost = cost;
          updateData.maintenanceHistory = device.maintenanceHistory;
        }
      }
      
      const updatedDevice = await this.deviceRepository.update(deviceId, updateData);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'DEVICE_MAINTENANCE_COMPLETED',
        userId: completedBy,
        resourceId: deviceId,
        resourceType: 'device',
        details: { maintenanceDetails, cost }
      });
      
      return updatedDevice;
    }
    
    // 设备报废
    async retireDevice(deviceId, retirementReason, retiredBy) {
      // 验证设备存在
      const device = await this.deviceRepository.findById(deviceId);
      if (!device) {
        throw new Error('设备不存在');
      }
      
      // 更新设备状态
      const updateData = {
        status: 'retired',
        retirementDate: new Date(),
        retirementReason,
        updatedAt: new Date()
      };
      
      // 清除当前分配信息
      updateData.currentUser = null;
      updateData.currentProject = null;
      
      const updatedDevice = await this.deviceRepository.update(deviceId, updateData);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'DEVICE_RETIRED',
        userId: retiredBy,
        resourceId: deviceId,
        resourceType: 'device',
        details: { retirementReason }
      });
      
      return updatedDevice;
    }
    
    // 搜索设备
    async searchDevices(keyword, filters = {}) {
      // 构建搜索查询
      const searchQuery = {
        $or: [
          { name: { $regex: keyword, $options: 'i' } },
          { model: { $regex: keyword, $options: 'i' } },
          { serialNumber: { $regex: keyword, $options: 'i' } },
          { manufacturer: { $regex: keyword, $options: 'i' } }
        ]
      };
      
      // 合并其他过滤条件
      const query = { ...searchQuery, ...filters };
      
      return this.deviceRepository.find(query);
    }
    
    // 获取即将过保的设备
    async getDevicesNearWarrantyExpiry(days = 30) {
      const futureDate = new Date();
      futureDate.setDate(futureDate.getDate() + days);
      
      const query = {
        warrantyExpiryDate: { $lte: futureDate, $gte: new Date() },
        status: { $ne: 'retired' }
      };
      
      return this.deviceRepository.find(query);
    }
  }
  ```
- **设备盘点功能**：
  - 扫码盘点（支持QR码、条形码）
  - 批量盘点操作
  - 盘点差异报告
  - 盘点历史记录
- **设备标签管理**：
  - 自动生成设备标签
  - 标签模板配置
  - 支持二维码/条形码打印
  - 标签信息自动同步
- **设备预警机制**：
  - 保修到期预警
  - 定期维护提醒
  - 设备使用率异常预警
  - 设备健康状态监控
- **性能优化**：
  - 设备数据索引优化
  - 批量操作处理
  - 数据缓存机制
  - 异步任务处理
- **集成接口**：
  - 与采购系统集成
  - 与财务系统集成
  - 与资产管理系统集成
  - 与项目管理模块集成

#### 4.15.2 开发板管理
- **功能概述**：专门针对嵌入式开发板的全生命周期管理，包括开发板的入库、分配、使用跟踪、固件管理和维护记录等功能
- **核心特性**：
  - 开发板分类与标识管理
  - 开发板使用状态跟踪
  - 固件版本管理
  - 开发板资源标签
  - 开发板连接信息管理
  - 开发板使用统计分析
  - 开发板依赖关系管理
- **开发板分类体系**：
  - **处理器架构**：ARM、RISC-V、x86、DSP、FPGA等
  - **开发板类型**：评估板、开发套件、核心板、定制板
  - **功能特性**：物联网、工业控制、消费电子、汽车电子
  - **通信接口**：WiFi、蓝牙、以太网、蜂窝网络、LoRaWAN等
- **数据模型设计**：
  ```javascript
  // 开发板模型
  const devBoardSchema = {
    id: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    boardModel: { type: String, required: true },
    manufacturer: { type: String },
    serialNumber: { type: String, unique: true },
    architecture: { type: String }, // ARM, RISC-V, x86等
    processor: { type: String },
    memory: { type: String },
    storage: { type: String },
    interfaces: [{ 
      type: String, // UART, SPI, I2C, USB等
      details: String
    }],
    communication: [{ type: String }], // WiFi, Bluetooth, Ethernet等
    status: { 
      type: String, 
      enum: ['available', 'in_use', 'maintenance', 'damaged', 'retired'],
      default: 'available'
    },
    currentUser: { type: String },
    currentProject: { type: String },
    firmwareVersion: { type: String },
    firmwareHistory: [{ 
      version: String,
      flashedBy: String,
      flashedDate: Date,
      notes: String
    }],
    usageStats: { 
      totalUsageHours: { type: Number, default: 0 },
      lastUsed: { type: Date },
      usageCount: { type: Number, default: 0 }
    },
    // 其他基础属性简化显示
  };
  ```
- **DevBoardService核心功能**：
  - 开发板的创建、查询、更新和删除
  - 开发板分配与使用状态管理
  - 固件版本管理与更新记录
  - 开发板连接信息管理
  - 使用统计与分析报告
  - 维护历史记录管理
  - 文档资料管理
- **固件管理功能**：
  - 固件版本追踪
  - 固件更新记录
  - 固件兼容性管理
  - 固件回滚支持
- **连接管理**：
  - 网络连接配置
  - 远程访问管理
  - 连接状态监控
  - 访问凭证安全存储
    }
    
    // 获取开发板详情
    async getDevBoardById(boardId) {
      const board = await this.boardRepository.findById(boardId);
      if (!board) {
        throw new Error('开发板不存在');
      }
      
      // 加载关联信息
      if (board.currentUser) {
        board.userInfo = await this.userService.findById(board.currentUser);
      }
      
      if (board.currentProject) {
        board.projectInfo = await this.projectService.findById(board.currentProject);
      }
      
      return board;
    }
    
    // 分配开发板给用户
    async assignDevBoardToUser(boardId, userId, projectId = null, purpose = '', startDate = new Date(), endDate = null, assignedBy) {
      // 验证开发板存在
      const board = await this.boardRepository.findById(boardId);
      if (!board) {
        throw new Error('开发板不存在');
      }
      
      // 验证开发板状态
      if (board.status !== 'available') {
        throw new Error(`开发板当前状态为${board.status}，无法分配`);
      }
      
      // 验证用户存在
      const user = await this.userService.findById(userId);
      if (!user) {
        throw new Error('用户不存在');
      }
      
      // 如果指定了项目，验证项目存在
      if (projectId) {
        const project = await this.projectService.findById(projectId);
        if (!project) {
          throw new Error('项目不存在');
        }
      }
      
      // 更新开发板状态和分配信息
      const updateData = {
        status: 'in_use',
        currentUser: userId,
        currentProject: projectId,
        updatedAt: new Date()
      };
      
      // 更新分配历史
      if (!board.assignedUsers) {
        board.assignedUsers = [];
      }
      
      board.assignedUsers.push({
        userId,
        projectId,
        startDate,
        endDate,
        purpose,
        assignedBy
      });
      
      updateData.assignedUsers = board.assignedUsers;
      
      // 更新使用统计
      if (!board.usageStats) {
        board.usageStats = { totalUsageHours: 0, usageCount: 0 };
      }
      board.usageStats.usageCount += 1;
      board.usageStats.lastUsed = new Date();
      updateData.usageStats = board.usageStats;
      
      const updatedBoard = await this.boardRepository.update(boardId, updateData);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'DEVBOARD_ASSIGNED',
        userId: assignedBy,
        resourceId: boardId,
        resourceType: 'dev_board',
        details: {
          assignedTo: userId,
          projectId,
          purpose,
          startDate,
          endDate
        }
      });
      
      // 发送通知给被分配用户
      await this.notificationService.send({
        type: 'DEVBOARD_ASSIGNED_TO_YOU',
        recipients: [userId],
        data: {
          boardId: board.id,
          boardName: board.name,
          boardModel: board.boardModel,
          assignedBy,
          purpose
        }
      });
      
      return updatedBoard;
    }
    
    // 归还开发板
    async returnDevBoard(boardId, returnReason = '', notes = '', returnedBy) {
      // 验证开发板存在
      const board = await this.boardRepository.findById(boardId);
      if (!board) {
        throw new Error('开发板不存在');
      }
      
      // 验证开发板状态
      if (board.status !== 'in_use') {
        throw new Error(`开发板当前状态为${board.status}，不是使用中状态`);
      }
      
      const currentUser = board.currentUser;
      
      // 计算使用时长
      let usageHours = 0;
      if (board.assignedUsers && board.assignedUsers.length > 0) {
        const lastAssignment = board.assignedUsers[board.assignedUsers.length - 1];
        if (lastAssignment.startDate && !lastAssignment.endDate) {
          const startTime = new Date(lastAssignment.startDate).getTime();
          const endTime = new Date().getTime();
          usageHours = (endTime - startTime) / (1000 * 60 * 60); // 转换为小时
          
          // 更新最近一次分配的结束日期
          lastAssignment.endDate = new Date();
          lastAssignment.returnReason = returnReason;
          lastAssignment.notes = notes;
          lastAssignment.usageHours = usageHours;
          
          // 更新使用统计
          if (!board.usageStats) {
            board.usageStats = { totalUsageHours: 0, usageCount: 0 };
          }
          board.usageStats.totalUsageHours += usageHours;
          
          updateData.assignedUsers = board.assignedUsers;
          updateData.usageStats = board.usageStats;
        }
      }
      
      // 更新开发板状态
      const updateData = {
        status: 'available',
        currentUser: null,
        currentProject: null,
        updatedAt: new Date()
      };
      
      const updatedBoard = await this.boardRepository.update(boardId, updateData);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'DEVBOARD_RETURNED',
        userId: returnedBy,
        resourceId: boardId,
        resourceType: 'dev_board',
        details: {
          returnedBy,
          returnReason,
          notes,
          usageHours
        }
      });
      
      return updatedBoard;
    }
    
    // 更新开发板固件
    async updateFirmware(boardId, firmwareVersion, flashedBy, notes = '') {
      // 验证开发板存在
      const board = await this.boardRepository.findById(boardId);
      if (!board) {
        throw new Error('开发板不存在');
      }
      
      // 更新固件历史
      if (!board.firmwareHistory) {
        board.firmwareHistory = [];
      }
      
      board.firmwareHistory.push({
        version: firmwareVersion,
        flashedBy,
        flashedDate: new Date(),
        notes
      });
      
      const updateData = {
        firmwareVersion,
        firmwareHistory: board.firmwareHistory,
        updatedAt: new Date()
      };
      
      const updatedBoard = await this.boardRepository.update(boardId, updateData);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'DEVBOARD_FIRMWARE_UPDATED',
        userId: flashedBy,
        resourceId: boardId,
        resourceType: 'dev_board',
        details: {
          firmwareVersion,
          notes
        }
      });
      
      return updatedBoard;
    }
    
    // 更新开发板连接信息
    async updateConnectionInfo(boardId, connectionInfo, updatedBy) {
      // 验证开发板存在
      const board = await this.boardRepository.findById(boardId);
      if (!board) {
        throw new Error('开发板不存在');
      }
      
      const updateData = {
        connectionInfo,
        updatedAt: new Date()
      };
      
      // 如果连接信息中包含IP地址，更新IP地址字段
      if (connectionInfo.ipAddress) {
        updateData.ipAddress = connectionInfo.ipAddress;
      }
      
      const updatedBoard = await this.boardRepository.update(boardId, updateData);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'DEVBOARD_CONNECTION_UPDATED',
        userId: updatedBy,
        resourceId: boardId,
        resourceType: 'dev_board',
        details: { connectionInfo }
      });
      
      return updatedBoard;
    }
    
    // 获取兼容的开发板列表
    async getCompatibleBoards(requirements) {
      const query = {};
      
      // 根据架构筛选
      if (requirements.architecture) {
        query.architecture = requirements.architecture;
      }
      
      // 根据通信接口筛选
      if (requirements.communication && requirements.communication.length > 0) {
        query.communication = { $all: requirements.communication };
      }
      
      // 根据处理器筛选
      if (requirements.processor) {
        query.processor = { $regex: requirements.processor, $options: 'i' };
      }
      
      // 只返回可用的开发板
      query.status = 'available';
      
      return this.boardRepository.find(query);
    }
    
    // 获取开发板使用统计
    async getBoardUsageStats(boardId) {
      // 验证开发板存在
      const board = await this.boardRepository.findById(boardId);
      if (!board) {
        throw new Error('开发板不存在');
      }
      
      // 计算使用统计数据
      const stats = {
        totalUsageHours: board.usageStats?.totalUsageHours || 0,
        usageCount: board.usageStats?.usageCount || 0,
        lastUsed: board.usageStats?.lastUsed,
        assignmentHistory: board.assignedUsers || [],
        firmwareHistory: board.firmwareHistory || []
      };
      
      // 计算平均使用时长
      if (stats.usageCount > 0) {
        stats.averageUsageHoursPerAssignment = stats.totalUsageHours / stats.usageCount;
      }
      
      return stats;
    }
    
    // 批量检查开发板可用性
    async checkAvailability(boardIds) {
      const boards = await this.boardRepository.find({ id: { $in: boardIds } });
      
      return boardIds.map(id => {
        const board = boards.find(b => b.id === id);
        return {
          boardId: id,
          available: board && board.status === 'available',
          board: board
        };
      });
    }
  }
  ```
- **开发板固件管理**：
  - 固件版本控制
  - 固件升级记录
  - 固件兼容性检查
  - 批量固件更新
- **开发板连接管理**：
  - SSH连接信息管理
  - 串口连接配置
  - 网络连接状态监控
  - 远程访问控制
- **开发板资源标签**：
  - 自定义资源标签
  - 标签快速筛选
  - 资源分类管理
  - 标签模板配置
- **开发板使用分析**：
  - 使用时长统计
  - 使用率分析
  - 使用趋势图表
  - 闲置资源识别
- **集成接口**：
  - 与CI/CD系统集成
  - 与固件管理系统集成
  - 与远程调试工具集成
  - 与项目管理模块集成
- **性能优化**：
  - 开发板数据索引优化
  - 批量操作处理
  - 实时状态缓存
  - 异步任务处理

#### 4.15.3 测试设备管理
- **功能概述**：针对嵌入式系统测试设备的专业管理功能，包括测试仪器、测试治具、信号发生器等设备的全生命周期管理、校准管理、使用跟踪和测试数据关联等功能
- **核心特性**：
  - 测试设备分类与标识管理
  - 设备校准周期管理
  - 测试设备预约管理
  - 测试数据关联跟踪
  - 设备精度监控
  - 测试设备使用分析
  - 测试设备维护管理
- **测试设备分类体系**：
  - **测量仪器**：示波器、万用表、频谱分析仪、逻辑分析仪
  - **信号源**：信号发生器、函数发生器、任意波形发生器
  - **通信测试**：网络分析仪、无线通信测试仪、蓝牙测试仪
  - **环境测试**：温湿度箱、振动测试仪、老化测试设备
  - **测试治具**：功能测试治具、针床治具、自动化测试平台
  - **电源设备**：可编程电源、电子负载、电池模拟器
- **数据模型设计**：
  ```javascript
  // 测试设备模型
  const testDeviceSchema = {
    id: { type: String, required: true, unique: true },
    name: { type: String, required: true },
    model: { type: String, required: true },
    manufacturer: { type: String },
    serialNumber: { type: String, unique: true },
    deviceType: { type: String, required: true }, // 设备类型
    category: { type: String }, // 设备分类
    accuracy: { type: String }, // 精度等级
    range: { type: String }, // 测量范围
    resolution: { type: String }, // 分辨率
    calibrationDueDate: { type: Date }, // 下次校准日期
    lastCalibrationDate: { type: Date }, // 最后校准日期
    calibrationInterval: { type: Number }, // 校准周期（天）
    calibrationHistory: [{ 
      date: Date,
      performedBy: String,
      organization: String,
      certificateNumber: String,
      notes: String
    }],
    status: { 
      type: String, 
      enum: ['available', 'in_use', 'calibration', 'maintenance', 'damaged', 'retired'],
      default: 'available'
    },
    currentUser: { type: String },
    currentProject: { type: String },
    currentTestId: { type: String }, // 当前关联的测试任务
    location: { type: String },
    usageStats: { 
      totalUsageHours: { type: Number, default: 0 },
      testSessionCount: { type: Number, default: 0 },
      lastUsed: { type: Date }
    },
    reservations: [{ 
      userId: String,
      startTime: Date,
      endTime: Date,
      purpose: String,
      projectId: String,
      status: { type: String, enum: ['pending', 'approved', 'rejected', 'completed'] }
    }],
    testDataLinks: [{ 
      testId: String,
      testName: String,
      date: Date,
      performedBy: String
    }],
    // 其他基础属性简化显示
  };
  ```
- **TestDeviceService核心功能**：
  - 测试设备的创建、查询、更新和删除
  - 设备分配与归还管理
  - 校准周期管理与校准记录维护
  - 设备预约管理与冲突检测
  - 设备精度监控与预警
  - 测试数据关联与历史追踪
  - 设备使用统计与分析
  - 维护管理与状态追踪
- **校准管理功能**：
  - 校准周期设置与自动提醒
  - 校准历史记录追踪
  - 校准状态管理
  - 校准证书管理
- **测试设备预约**：
  - 预约创建与审批流程
  - 时间冲突检测
  - 预约状态管理
  - 预约通知与提醒
- **精度管理**：
  - 精度参数记录与追踪
  - 精度异常检测
  - 精度降级预警
- **测试数据关联**：
  - 测试任务与设备关联
  - 测试结果数据追溯
  - 测试历史记录查询
      
      // 更新设备的预约列表
      if (!device.reservations) {
        device.reservations = [];
      }
      
      device.reservations.push(reservation);
      
      const updateData = {
        reservations: device.reservations,
        updatedAt: new Date()
      };
      
      const updatedDevice = await this.deviceRepository.update(deviceId, updateData);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'TESTDEVICE_RESERVED',
        userId: reservedBy,
        resourceId: deviceId,
        resourceType: 'test_device',
        details: {
          userId,
          startTime,
          endTime,
          purpose,
          projectId
        }
      });
      
      return updatedDevice;
    }
    
    // 审批设备预约
    async approveReservation(deviceId, reservationIndex, approved, reason = '', approvedBy) {
      // 验证设备存在
      const device = await this.deviceRepository.findById(deviceId);
      if (!device || !device.reservations || !device.reservations[reservationIndex]) {
        throw new Error('设备或预约记录不存在');
      }
      
      const reservation = device.reservations[reservationIndex];
      
      if (reservation.status !== 'pending') {
        throw new Error('只能审批待处理的预约');
      }
      
      // 检查是否有时间冲突（只有在批准时才检查）
      if (approved) {
        const hasConflict = await this.checkReservationConflict(
          deviceId, 
          reservation.startTime, 
          reservation.endTime, 
          reservationIndex
        );
        if (hasConflict) {
          throw new Error('该时间段已有其他已批准的预约');
        }
      }
      
      // 更新预约状态
      reservation.status = approved ? 'approved' : 'rejected';
      reservation.approvedBy = approvedBy;
      reservation.approvedAt = new Date();
      reservation.approvalReason = reason;
      
      const updateData = {
        reservations: device.reservations,
        updatedAt: new Date()
      };
      
      const updatedDevice = await this.deviceRepository.update(deviceId, updateData);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: approved ? 'RESERVATION_APPROVED' : 'RESERVATION_REJECTED',
        userId: approvedBy,
        resourceId: deviceId,
        resourceType: 'test_device',
        details: {
          reservationId: reservationIndex,
          userId: reservation.userId,
          startTime: reservation.startTime,
          endTime: reservation.endTime,
          reason
        }
      });
      
      // 发送通知给预约用户
      await this.notificationService.send({
        type: approved ? 'RESERVATION_APPROVED' : 'RESERVATION_REJECTED',
        recipients: [reservation.userId],
        data: {
          deviceId,
          deviceName: device.name,
          startTime: reservation.startTime,
          endTime: reservation.endTime,
          approvedBy,
          reason
        }
      });
      
      return updatedDevice;
    }
    
    // 检查预约时间冲突
    async checkReservationConflict(deviceId, startTime, endTime, excludeReservationIndex = null) {
      const device = await this.deviceRepository.findById(deviceId);
      if (!device || !device.reservations) {
        return false;
      }
      
      const start = new Date(startTime).getTime();
      const end = new Date(endTime).getTime();
      
      // 检查是否有已批准的预约时间重叠
      return device.reservations.some((reservation, index) => {
        // 排除指定的预约（用于更新或审批时）
        if (excludeReservationIndex !== null && index === excludeReservationIndex) {
          return false;
        }
        
        // 只检查已批准的预约
        if (reservation.status !== 'approved') {
          return false;
        }
        
        const resStart = new Date(reservation.startTime).getTime();
        const resEnd = new Date(reservation.endTime).getTime();
        
        // 检查时间重叠
        return !(end <= resStart || start >= resEnd);
      });
    }
    
    // 关联测试数据
    async linkTestData(deviceId, testInfo, linkedBy) {
      // 验证设备存在
      const device = await this.deviceRepository.findById(deviceId);
      if (!device) {
        throw new Error('测试设备不存在');
      }
      
      // 更新测试数据链接
      if (!device.testDataLinks) {
        device.testDataLinks = [];
      }
      
      device.testDataLinks.push({
        testId: testInfo.testId,
        testName: testInfo.testName,
        date: new Date(),
        performedBy: linkedBy
      });
      
      const updateData = {
        testDataLinks: device.testDataLinks,
        updatedAt: new Date()
      };
      
      const updatedDevice = await this.deviceRepository.update(deviceId, updateData);
      
      // 记录审计日志
      await this.auditLogService.log({
        action: 'TESTDATA_LINKED_TO_DEVICE',
        userId: linkedBy,
        resourceId: deviceId,
        resourceType: 'test_device',
        details: {
          testId: testInfo.testId,
          testName: testInfo.testName
        }
      });
      
      return updatedDevice;
    }
    
    // 获取需要校准的设备
    async getDevicesDueForCalibration(days = 30) {
      const futureDate = new Date();
      futureDate.setDate(futureDate.getDate() + days);
      
      const query = {
        calibrationDueDate: { $lte: futureDate, $gte: new Date() },
        status: { $ne: 'retired' }
      };
      
      return this.deviceRepository.find(query);
    }
    
    // 获取测试设备使用统计
    async getDeviceUsageStats(deviceId) {
      // 验证设备存在
      const device = await this.deviceRepository.findById(deviceId);
      if (!device) {
        throw new Error('测试设备不存在');
      }
      
      // 计算使用统计数据
      const stats = {
        totalUsageHours: device.usageStats?.totalUsageHours || 0,
        testSessionCount: device.usageStats?.testSessionCount || 0,
        lastUsed: device.usageStats?.lastUsed,
        calibrationStatus: device.calibrationDueDate ? 
          (new Date(device.calibrationDueDate) < new Date() ? 'expired' : 'valid') : 
          'unknown',
        calibrationDueDate: device.calibrationDueDate,
        lastCalibrationDate: device.lastCalibrationDate,
        testDataLinks: device.testDataLinks || []
      };
      
      return stats;
    }
  }
  ```
- **校准管理功能**：
  - 校准周期设置
  - 校准到期提醒
  - 校准历史记录
  - 校准证书管理
  - 校准状态监控
  - 自动校准调度
- **测试设备预约**：
  - 预约时间管理
  - 预约冲突检测
  - 预约审批流程
  - 预约提醒通知
  - 预约统计分析
- **精度管理**：
  - 设备精度追踪
  - 精度退化分析
  - 精度等级划分
  - 测量误差记录
- **测试数据关联**：
  - 测试任务关联
  - 测试结果溯源
  - 数据查询分析
  - 测试报告生成
- **设备监控**：
  - 设备在线状态
  - 使用状态监控
  - 异常状态报警
  - 远程诊断支持
- **集成接口**：
  - 与测试管理系统集成
  - 与校准管理系统集成
  - 与项目管理模块集成
  - 与报表生成系统集成
- **性能优化**：
  - 索引优化
  - 批量操作处理
  - 预约算法优化
  - 缓存机制实现

#### 4.15.4 资源统计分析
- **功能概述**：提供嵌入式项目硬件资源的全面统计与分析功能，帮助管理人员了解资源使用效率、成本分布和未来需求预测，支持数据可视化和多维度报表生成
- **核心特性**：
  - 多维度资源统计与分析
  - 自定义报表生成
  - 资源利用率监控
  - 成本分析与预算管理
  - 使用趋势预测
  - 资源优化建议
  - 数据可视化展示
  - 导出与分享功能
- **统计维度**：
  - **设备类型维度**：按硬件设备、开发板、测试设备等类型统计
  - **时间维度**：按日、周、月、季度、年度统计资源使用情况
  - **项目维度**：按项目统计资源分配与使用情况
  - **人员维度**：统计各工程师的资源占用与使用效率
  - **状态维度**：统计不同状态（可用、占用、维护中、报废等）的资源数量
  - **成本维度**：统计设备采购、维护、校准等成本数据
- **数据模型设计**：
  - **资源统计模型**：存储统计数据、维度信息、时间周期、数据点集合、汇总数据、过滤器设置等
  - **自定义报表配置模型**：管理报表名称、类型、多维度配置、指标列表、过滤条件、可视化设置、调度配置等
  - **数据模型要点**：支持多维度数据聚合、时间序列分析、自定义过滤条件、多种可视化展示
- **ResourceStatisticsService核心功能**：
  - 资源使用统计报表生成（支持设备类型、项目、人员、状态等多维度）
  - 资源利用率分析（计算使用率、可用率及趋势分析）
  - 资源成本分析（按类型、项目等维度统计成本）
  - 自定义报表创建与管理
  - 报表导出功能（支持Excel、CSV、PDF格式）
  - 时间序列数据生成与分析
- **关键报表类型**：
  - 资源占用统计报表
  - 资源利用率趋势报表
  - 项目资源分配报表
  - 成本分析报表
  - 设备维护提醒报表
  - 使用效率分析报表
- **可视化组件**：
  - 饼图：资源类型分布和状态分布展示
  - 柱状图：不同维度的资源数量对比
  - 折线图：资源使用趋势分析
  - 热力图：资源使用密度和效率可视化
  - 仪表盘：关键指标的实时监控
  - 表格：详细数据的展示和导出
- **性能优化**：
  - 数据预聚合：定期预计算常用统计数据
  - 缓存机制：缓存统计结果，减少重复计算
  - 分页查询：大报表支持分页加载

### 4.16 标签系统详细设计

#### 4.16.1 标签系统概述
- **功能目标**：实现成品和人员的标签化管理，支持灵活的分类搜索和人员技能识别
- **标签类型**：
  - 成品标签：用于对系统中的成品进行分类和属性描述
  - 技能标签：用于标注工程师和管理员的擅长领域

#### 4.16.2 权限控制规则
- **标签管理权限**：
  - 超级管理员、高级管理员：可创建、编辑、删除所有类型的标签
  - 中级管理员：可管理已有的标签，但不可删除系统核心标签
  - 普通管理员：仅可查看标签列表，不可修改

- **成品标签操作权限**：
  - 所有有成品管理权限的用户均可添加/移除成品标签
  - 标签搜索权限与成品查看权限保持一致

- **技能标签操作权限**：
  - 工程师和普通管理员：可添加/移除/更新自己的技能标签
  - 中级管理员及以上：可添加/移除/更新所有用户的技能标签
  - 高级管理员和超级管理员：不能被普通用户添加技能标签（保持最高权限层级的独立性）

#### 4.16.3 标签管理功能实现
- **标签管理核心功能**：
  - 创建、编辑、删除标签
  - 标签与成品关联管理
  - 用户技能标签管理
  - 标签权限验证
  - 标签冲突检测
- **标签服务主要功能**：
  - 权限验证机制
  - 标签唯一性检查
  - 用户技能标签关联
  - 标签批量操作支持

#### 4.16.4 标签搜索与分类功能
- **成品标签搜索**：
  - 支持多标签组合搜索（AND/OR逻辑）
  - 支持标签+关键词混合搜索
  - 搜索结果支持按相关性、创建时间等排序

- **人员技能搜索**：
  - 可按技能标签查找擅长该技能的人员
  - 支持按熟练度筛选（如筛选4星以上精通人员）
  - 可用于项目人员匹配推荐

#### 4.16.5 标签数据统计与分析
- **标签使用统计**：
  - 统计各标签的使用频率和分布情况
  - 识别热门技能和热门产品属性

- **人员技能分析**：
  - 部门技能分布图
  - 个人技能雷达图
  - 技能缺口分析

#### 4.16.6 标签系统与其他模块集成
- **与项目管理集成**：
  - 项目成员技能匹配度分析
  - 基于技能标签的任务分配建议

- **与资料管理集成**：
  - 支持按技能标签推荐相关学习资料
  - 资料与技能标签的关联展示

- **与审批工作流集成**：
  - 基于技能标签的审批人推荐
  - 复杂审批流程中的专家意见获取

## 5. 数据库设计

### 5.1 数据库设计优化
- **数据库选型**：PostgreSQL（推荐）提供更好的并发性能和扩展性
- **索引优化**：
  - 为高频查询字段添加索引
  - 定期分析索引使用情况
- **查询优化视图**：
  ```sql
  CREATE VIEW project_summary AS 
  SELECT p.id, p.name, p.status, p.create_time, 
         COUNT(t.id) as task_count, 
         COUNT(CASE WHEN t.status = 'completed' THEN 1 END) as completed_tasks
  FROM projects p
  LEFT JOIN tasks t ON p.id = t.project_id
  GROUP BY p.id;
  ```

### 5.2 标签系统表结构设计
- **标签主表（tags）**：
- **标签系统数据模型**：
  - **标签主表(tags)**：存储标签基本信息，包括名称、描述、类型(product/skill)、分类、显示颜色等，保证同一类型下标签名称唯一
  - **成品标签关联表(product_tags)**：建立成品与标签的多对多关系，包含创建者信息和时间戳
  - **用户技能标签关联表(user_skill_tags)**：记录用户与技能标签的关联，包含熟练度评级(1-5星)和权限控制信息
  
- **数据模型设计要点**：
  - 所有关联表采用外键约束，确保数据完整性
  - 合理建立索引优化查询性能
  - 实现唯一约束避免重复关联
  - 记录操作人信息支持审计追踪

## 6. API接口设计

### 6.1 API设计规范与优化
- **统一API路径格式**
- **标准化请求响应结构**
- **API版本控制**
- **接口安全设计**

（此处包含完整API接口设计内容）

## 7. 安全与权限设计

### 7.1 系统安全增强
- **API速率限制**
- **SQL注入防护**
- **XSS攻击防护**
- **CSRF攻击防护**

### 7.2 权限系统优化
- **RBAC权限模型**
- **细粒度权限控制**
- **权限缓存机制**

（此处包含完整安全与权限设计内容）

## 8. 代码规范
（此处包含代码规范详细内容）

## 9. 测试计划

### 9.1 性能测试计划
- **数据库性能测试**
- **API响应时间测试**
- **并发用户测试**
- **大文件上传下载测试**

（此处包含完整测试计划内容）

### 9.2 实施路径与优先级

#### 9.2.1 短期优化（1-3个月）
- 数据库索引优化和PRAGMA参数调整
- 权限验证中间件统一
- 文件分块上传实现
- API响应格式标准化
- 全局错误处理中间件实现
- 声明式事务装饰器开发

#### 9.2.2 中期改进（3-6个月）
  - 数据模型规范化，减少JSON字段使用
  - 完善RBAC权限模型与六级角色体系的集成
  - 实现存储抽象层
  - 前后端完全分离架构调整
  - 状态机模式实现项目状态管理
  - 高级搜索功能开发
  - 批量操作功能实现
  - 标签系统开发与集成（成品标签和人员技能标签）
  - 标签搜索与分类功能实现

#### 9.2.3 长期重构（6-12个月）
- 数据库迁移到PostgreSQL
- 微服务架构转型
- 完整的DDD实施
- 分布式部署支持
- API网关实现
- 完整的通知中心系统
- 缓存策略全面应用
- 监控和日志系统增强
- 标签数据分析与可视化平台
- 基于标签的智能推荐系统（项目人员匹配、资料推荐）
通过以上优化方案，可以显著提升系统的性能、可扩展性和可维护性，同时保持本地部署的优势，更好地满足中小型嵌入式开发企业的长期发展需求。
